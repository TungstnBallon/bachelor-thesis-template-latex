\chapter{Implementation}
\label{chapter:Implementation}

\section{Type Conversion}
- polars has its own type system not compatible with Jayvee valuetypes
- need for conversion between the two
- jayvee also has InternalValueRepresentation (stuff that expressions can evaluate to)
- wrong apporach:
- add the polars datatypes to internalvaluerepresentation
- they do not contain actual data, they are values representing types
- tried to do strategy on valuetypeproviders, didn't work
- right approach:
- jayvee is able to convert between valuetypes and polars datatypes when required
- dtype -> vtype: add \Verb|fromPolarsDType| method to \Verb|ValueTypeProvider|. unsupported plds throw an error.
- unsupported: pl.Categorical, pl.Date, pl.DateTime, pl.List, pl.Null, pl.Struct
- vtype -> dtype: add \Verb|toPolarsDataType| method to interface \Verb|ValueType|. unsupported vts return undefined.
- unsupported: EmptyCollection, collection(if inner is unsupported), valuetype-assignment, transform, regex, constraint, cell-range

- InternalValueRepresentation
- gets new typeguards
- prev: could only be used to narrow down internalvaluerepresentation it is
- now: unknwon types can be tested
- pl.Expr should be an atomicinternalvaluerepresentation but is kept seperate for allow the ts backend to coexist


\section{Table}
\subsection{abstract Table}
Jayvee implements \Verb{IOTypeImplementation<IOType.TABLE>} in \Verb{libs/execution/src/lib/types/io-types/table.ts}.
To increase clarity, the abstract \Verb|TableColumn| class and its subclasses \Verb|PolarsTableColumn| and \Verb|TsTableColumn| are moved into their own file \Verb|table-column.ts|.
\Verb|Table| defines defines abstract methods for its subclasses to implement and directly implements general behaviour in static methods. %TODO?: code snippet here?
\begin{figure}
	\begin{plantuml}
		@startuml
		abstract class Table {
		{abstract} <<getter>> nRows(): number
			{abstract} <<getter>>  nColumns(): number
			{abstract} <<getter>> columns(): ReadonlyArray<TableColumn>
			{abstract} withColumn(column: TableColumn): Table
			{abstract} hasColumn(name: string): boolean
			{abstract} getColumn(name: string): TableColumn | undefined
			{abstract} getRow(id: number): TableRow
			{abstract} clone(): Table
			{abstract} acceptVisitor<R>(visitor: IoTypeVisitor<R>): R
			{abstract} isPolars(): this is PolarsTable
			{abstract} isTypescript(): this is TsTable
			{static} generateDropTableStatement(tableName: string): string
			{abstract} generateInsertValuesStatement(tableName: string, context: ExecutionContext): string;
		{abstract} generateCreateTableStatement(tableName: string, context: ExecutionContext): string;
		}
		@enduml
	\end{plantuml}
	\caption{The class diagram of the \Verb{Table} class}
	\label{fig:table_uml}
\end{figure}

\subsubsection{changes compared to old table}
- The \Verb|addColumn| method was replaced with the \Verb|withColumn| metod
- \Verb|isPolars| and \Verb|isTypescript| typeguards were added
- utilised the \Verb|get| keyword for \Verb|getNumberOfColumns|


\subsection{PolarsTable}
\Verb|PolarsTable| extends \Verb|Table| and thereby also implements \Verb|IOTypeImplementation<IOType.Table>|.
\begin{figure}
	\begin{plantuml}
		@startuml
		class PolarsTable {
				-df: polars.DataFrame
				-valueTypeProvider: ValueTypeProvider
				<<getter>> nRows(): number
				<<getter>> nColumns(): number
				<<getter>> columns(): readonly PolarsTableColumn[]
				getTypes(): ValueType[]
				generateInsertValuesStatement(tableName: string): string
				generateCreateTableStatement(tableName: string): string
				withColumn(column: PolarsTableColumn): PolarsTable
				withColumnFromInternal(expr: PolarsInternal): PolarsTable
				hasColumn(name: string): boolean
				getColumn(name: string): PolarsTableColumn | undefined
				getRow(id: number): TableRow
				clone(): PolarsTable
				acceptVisitor<R>(visitor: IoTypeVisitor<R>): R
				isPolars(): this is PolarsTable
				isTypescript(): this is TsTable
				toString(): string
				writeIpc(options?: WriteIPCOptions): Buffer
				writeIpcTo(destination: string | Writable, options?: WriteIPCOptions): void
			}
		@enduml
	\end{plantuml}
	\caption{The class diagram of the \Verb{PolarsTable} class}
	\label{fig:polarstable_uml}
\end{figure}

It wraps the \Verb|polars.DataFrame| class and uses its methods to implement the abstract methods from \Verb|Table|, except with the general abstract types like \Verb|TableColumn| or \Verb|Table| replaced with types interacting with polars like \Verb|PolarsTable| or \Verb|PolarsTableColumn|.

\subsubsection{ValueTypeProvider}
This tells the jayvee interpreter jayvee specific type a value has.
This information is saved on a per column basis in the typescript backend.
The polars backend cannot do this, because the polars has its own valuetype system.
The Valuetype will have to be reinferred anytime a column is requested. %FIXME: getColumn() is called.

\begin{listing}
	\begin{minted}{typescript}
override withColumn(column: PolarsTableColumn): PolarsTable {
  const ndf = this.df.withColumn(column.series);
  return new PolarsTable(ndf, this.valueTypeProvider);
}
	\end{minted}
	\caption{An exemplary implementation in PolarsTable}
	\label{lst:polarstable_impl_example}
\end{listing}

\section{TableColumn}
Originally \Verb|TableColumn| was just %FIXME: "just" bad
an interface (see \ref{lst:table_column_interface})
\begin{listing}
	\begin{minted}{typescript}
interface TableColumn<
  T extends InternalValueRepresentation = InternalValueRepresentation,
> {
  values: T[];
  valueType: ValueType;
}
	\end{minted}
	\caption{The old implementation of TableColum}
	\label{lst:table_column_interface}
\end{listing}


Now, we use the same approach as with the tables, by creating an abstract superclass \Verb|TableColumn| (see \ref{fig:tablecolumn_uml}) that both \Verb|TsTableColumn|, with the old functionality, and \Verb|PolarsTableColumn| implement.

\begin{figure}
	\begin{plantuml}
		@startuml
		abstract class TableColumn{
				{abstract} <<getter>> valueType(): ValueType
					{abstract} <<getter>> length(): number
					{abstract} <<getter>> name(): string
					{abstract} <<setter>> name(newName: string)
				{abstract} nth(n: number): InternalValueRepresentation | undefined | null
					{abstract} clone(): TableColumn
					{abstract} isPolars(): this is PolarsTableColumn
					{abstract} isTypescript(): this is TsTableColumn
			}
		@enduml
	\end{plantuml}
	\caption{The \Verb|TableColumn| class diagram}
	\label{fig:tablecolumn_uml}
\end{figure}

\begin{figure}
	\begin{plantuml}
		@startuml
		class PolarsTableColumn {
				-_valueType: ValueType;
				-_series: polars.Series
				PolarsTableColumn(_series: Series, valueType: ValueType | ValueTypeProvider)
				<<getter>> valueType(): ValueType
				<<getter>> series(): Readonly<pl.Series>
				<<getter>> length(): number
				<<getter>> name(): string
				<<setter>> name(newName: string)
				nth(n: number): InternalValueRepresentation | undefined | null
				clone(): PolarsTableColumn
				isPolars(): this is PolarsTableColumn
				isTypescript(): this is TsTableColumn
			}
		@enduml
	\end{plantuml}
	\caption{The \Verb|PolarsTableColumn| class diagram}
	\label{fig:polastablecolumn_uml}
\end{figure}

- The constructor accepts both valuetype and valuetypeProvider
- if it's a valuetypeprovider the valuetype is inferred from the series dtype with the \Verb{fromPolarsDType} method.
- \Verb|nth| has to cast \Verb|any| to \Verb|InternalValueRepresentation| using \Verb|INTERNAL_VALUE_REPRESENTATION_TYPEGUARD| (new).
- it return \Verb|null| in case of the value being \Verb|null|
- most methods map more ot less directly onto series methods.

- the \Verb|TsTableColumn| implementation is also new
- now it has a \Verb|name| attribute.
% maybe TODO?: plantuml diag.
- compared to polarstablecolumn:
- clone is hacky
- everything gets serialized to json -> deserialize into object -> reassert type information
- this is because normal nodejs deep clone looses type information
- push and drop are supported, because they are required by the typescript blocks


\section{TableInterpreter}
- same approach as always (strategy).
- move previous implementation into \Verb|TsTableInterpreter|
- create abstract class \Verb|TableInterpreter|
- create new class \Verb|PolarsTableInterpreter|
- \Verb|toPolarsDataTypeWithLogs| is its own mehtod to enable code sharing with other table blocks.
- can't be in language-server because circular dependency
- uses the already present \Verb|ColumnDefintionEntry|


\begin{figure}
	\begin{plantuml}
		@startuml
		abstract class TableInterpeter {
		doExecute(inputSheet: Sheet, context: R.ExecutionContext): Promise<R.Result<R.Table>>
		# {abstract} constructAndValidateTable(sheet: Sheet, header: boolean, columnEntries: ColumnDefinitionEntry[], context: ExecutionContext): Table
		#deriveColumnDefinitionEntriesWithoutHeader(columnDefinitions: ValuetypeAssignment[], context: ExecutionContext): ColumnDefinitionEntry[]
		#deriveColumnDefinitionEntriesFromHeader(columnDefinitions: ValuetypeAssignment[], headerRow: string[], context: ExecutionContext): ColumnDefinitionEntry[]
		#parseAndValidateValue(value: string, valueType: ValueType, context: ExecutionContext): InternalValueRepresentation | undefined
		}
		@enduml
	\end{plantuml}
	\caption{}
	\label{fig:tableinterpreter_uml}
\end{figure}

\begin{figure}
	\begin{plantuml}
		@startuml
		class PolarsTableInterpreterExecutor {
		+ {static} <<readonly>> type: 'PolarsTableInterpreter' = 'PolarsTableInterpreter';
		# constructAndValidateTable(sheet: Sheet, header: boolean, columnEntries: ColumnDefinitionEntry[], context: ExecutionContext): PolarsTable
		- constructSeries(rows: readonly (readonly string[])[], columnEntry: ColumnDefinitionEntry, context: ExecutionContext): pl.Series
		}
		@enduml
	\end{plantuml}
	\caption{}\label{fig:polarstableinterpreter_uml}
\end{figure}



\section{TableTransformer}
- again strategy.
- steps:
1. check input coluns exist
2. create executor
3. check input columns match the transform input types.
3.1 compare the nth input column type to the nth transform input type and check with \Verb|isConvertibleTo|
3.1 return variableToColumnMap (varname -> columnexpr)
%maybee TODO: listing
4. execute the transform with the variabletocolumnmap -> returns polars expr that will perform the transform if applied to a table.
- wierd naming is to remain similar to the typescript implementation
5. extend the expression to include a renaming of the new column to \Verb|outputColumn|
6. apply the expression to the input table and return the resulting table

\subsection{Transforms}
- again strategy.
- previos tranform execution
1. pretend new table with input columns
2. execute expression for each row oth that (pretend) table
3. add resulting column (transforms only allow for one result): if outputname is the same as another column that one gets replaced





\section{SQLiteLoader}





