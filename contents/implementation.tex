\chapter{Implementation}
\label{chapter:Implementation}

\section{Type Conversion}
- dtype -> vtype: add \Verb|fromPolarsDType| method to \Verb|ValueTypeProvider|. unsupported plds throw an error.
- unsupported: pl.Categorical, pl.Date, pl.DateTime, pl.List, pl.Null, pl.Struct
- vtype -> dtype: add \Verb|toPolarsDataType| method to interface \Verb|ValueType|. unsupported vts return undefined.
- unsupported: EmptyCollection, collection(if inner is unsupported), valuetype-assignment, transform, regex, constraint, cell-range

- InternalValueRepresentation
- gets new typeguards
% TODO: better explanation
- prev: could only be used to narrow down internalvaluerepresentation it is
- now: unknwon types can be tested
- pl.Expr should be an atomicinternalvaluerepresentation but is kept seperate for allow the ts backend to coexist


\section{Table}
\subsection{abstract Table}
Jayvee implements \Verb{IOTypeImplementation<IOType.TABLE>} in \Verb{libs/execution/src/lib/types/io-types/table.ts}.
To increase clarity, the abstract \Verb|TableColumn| class and its subclasses \Verb|PolarsTableColumn| and \Verb|TsTableColumn| are moved into their own file \Verb|table-column.ts|.
\Verb|Table| defines defines abstract methods for its subclasses to implement and directly implements general behaviour in static methods. %TODO?: code snippet here?



\subsection{PolarsTable}
It wraps the \Verb|polars.DataFrame| class and uses its methods to implement the abstract methods from \Verb|Table|, except with the general abstract types like \Verb|TableColumn| or \Verb|Table| replaced with types interacting with polars like \Verb|PolarsTable| or \Verb|PolarsTableColumn|.
- adapter pattern

The Valuetype will have to be reinferred anytime a column is requested. %FIXME: getColumn() is called.
\begin{listing}
	\begin{minted}{typescript}
override withColumn(column: PolarsTableColumn): PolarsTable {
  const ndf = this.df.withColumn(column.series);
  return new PolarsTable(ndf, this.valueTypeProvider);
}
	\end{minted}
	\caption{An exemplary implementation in PolarsTable}
	\label{lst:polarstable_impl_example}
\end{listing}

\section{TableColumn}

- The constructor accepts both valuetype and valuetypeProvider
- if it's a valuetypeprovider the valuetype is inferred from the series dtype with the \Verb{fromPolarsDType} method.
- \Verb|nth| has to cast \Verb|any| to \Verb|InternalValueRepresentation| using \Verb|INTERNAL_VALUE_REPRESENTATION_TYPEGUARD| (new).
- it return \Verb|null| in case of the value being \Verb|null|
- most methods map more ot less directly onto series methods.

- the \Verb|TsTableColumn| implementation is also new
- now it has a \Verb|name| attribute.
% maybe TODO?: plantuml diag.
- compared to polarstablecolumn:
- clone is hacky
- everything gets serialized to json -> deserialize into object -> reassert type information
- this is because normal nodejs deep clone looses type information
- push and drop are supported, because they are required by the typescript blocks


\section{new executors}
- we insert if statements into getExecutorForBlockype to change what BlockExecutorClass type is being searched for.




\subsection{TableInterpreter} %TODO
static methods


\section{FileToTableIntepreter}

\section{LocalFileToTableIntepreter}
- no circular dependencies rule prevents code sharing with LocalFileExtractor -> copy logic.
- use the static method csvOptions of PolarsTableInterpreterExecutor to reuse the code there and get csv parser options
- leave all of the actual filereading to polars


\section{TableTransformer}
- again strategy.
- steps:
1. check input coluns exist
2. create executor
3. check input columns match the transform input types.
3.1 compare the nth input column type to the nth transform input type and check with \Verb|isConvertibleTo|
3.1 return variableToColumnMap (varname -> columnexpr)
%maybee TODO: listing
4. execute the transform with the variabletocolumnmap -> returns polars expr that will perform the transform if applied to a table.
- wierd naming is to remain similar to the typescript implementation
5. extend the expression to include a renaming of the new column to \Verb|outputColumn|
6. apply the expression to the input table and return the resulting table

\subsection{Transforms}
- again strategy.
- previos tranform execution
1. pretend new table with input columns
2. execute expression for each row oth that (pretend) table
3. add resulting column (transforms only allow for one result): if outputname is the same as another column that one gets replaced

\subsubsection{Expressions}
- there is no \Verb|ExpressionEvaluator| class, a function \Verb|evaluateExpression|
- strategy pattern, the way we did it previously,is out.
- directly modifying the the values from the dataframe would require converting it back into a js datastructure, apply the expression, create new dataframe -> SLOW!
- utilise \Verb|polars.Expr|, which describe changes made to a polars DataFrame.
- add new method \Verb|polarsEvaluateExpression| that replicates the structure of \Verb|evaluateExpression|
- 1. free variable -> retrieve from context, if InternalValueRepresentation wrap in pl.lit and return.
- 2. literal -> wrap in pl.lit and return
- 3. other -> get evaluator from context / DefaultOperatorRegistry, evaluateExpression, return resulting pl.Expr or undefined
- this snippet \ref{lst:pl_expr_example} multiplies the values in column "a" with those in column "b".
\begin{listing}
	\begin{minted}{typescript}
use {pl} from 'nodejs-polars';
const dataFrame = ...;
const newDataFrame = dataFrame.withColumn(pl.col("a").mul(pl.col("b")))
	\end{minted}
	\caption{How to multiply column "a" and "b" of a dataframe}
	\label{lst:pl_expr_example}
\end{listing}
- instead of calculating the new values directly, evaluators now return pl.Expression

\begin{figure}
	\begin{plantuml}
		@startuml
		start
		if (""expr"" is a free variable) then (yes)
		:retrieve the ""value"" of ""expr"" from context;
		if (""value"" is ""InternalValueRepresentation"") then (yes)
		:return ""pl.lit(value)"";
		stop
		else (no)
		:return ""value"";
		stop
		endif
		elseif (""expr"" is a valueLiteral) then (yes)
		:evaluate the ""value"" of ""expr"";
		if (""value === undefined"") then (true)
		:return ""undefined"";
		stop
		else (false)
		:return ""pl.lit(value)"";
		stop
		endif
		else
		:use the expressions n-ness (unary, binary, tertiary) and its
		operator to get the fitting evaluator from ""evaluationContext"";
		:call the ""eval.polarsEvaluate"" method;
		:return the result of that;
		stop
		endif
		@enduml
	\end{plantuml}
	\caption{
		Activity diagram of the \Verb|polarsEvaluateExpression| function.
		\Verb|expr| is the expression that should be evaluated. %FIXME: caption
	}
	\label{fig:uml:polars_evaluate_expression}
\end{figure}


\begin{figure}
	\begin{plantuml}
		@startuml
		class AdditionOperatorEvaluator {
				AdditionOperatorEvaluator()
				doEvaluate(left: number, right: number): number
				polarsDoEvaluate(left: polars.Expr, right: polars.Expr): polars.Expr
			}

		class RoundOperatorEvaluator {
				RoundOperatorEvaluator()
				doEvaluate(operandValue: number): number
				polarsDoEvaluate(operand: polars.Expr): polars.Expr
			}
		DefaultUnaryOperatorEvaluator <|-- RoundOperatorEvaluator: DefaultUnaryOperatorEvaluator<number, number>

		abstract class DefaultBinaryOperatorEvaluator<L extends InternalValueRepresentation, R extends InternalValueRepresentation, T extends InternalValueRepresentation> {
		DefaultBinaryOperatorEvaluator(operator, leftValueTypeGuard, rightValueTypeGuard)
		+ <<readonly>> operator: BinaryExpressionOperator
		- <<readonly>> leftValueTypeGuard: InternalValueRepresentationTypeguard<L>
		- <<readonly>> rightValueTypeGuard: InternalValueRepresentationTypeguard<R>
		evaluate(expression: BinaryExpression, evaluationContext: EvaluationContext, wrapperFactories: WrapperFactoryProvider, strategy: EvaluationStrategy, validationContext: ValidationContext | undefined): T | undefined
		polarsEvaluate(expression: BinaryExpression, evaluationContext: EvaluationContext, wrapperFactories: WrapperFactoryProvider, strategy: EvaluationStrategy, validationContext: ValidationContext | undefined): polars.Expr | undefined
		# {abstract} doEvaluate(leftValue: L, rightValue: R, expression: BinaryExpression, context: ValidationContext | undefined): T | undefined
		# polarsDoEvaluate(_left: polars.Expr, _right: polars.Expr, expression: BinaryExpression, context: ValidationContext): polars.Expr | undefined
		}
		DefaultBinaryOperatorEvaluator <|-- AdditionOperatorEvaluator: DefaultBinaryOperatorEvaluator<number, number, number>

		abstract class DefaultUnaryOperatorEvaluator<0 extends InternalValueRepresentation T extends InternalValueRepresentation> {
		DefaultUnaryOperatorEvaluator(operator: string, operandValueTypeGuard: InternalValueRepresentationTypeguard<O>)
		+ <<readonly>> operator: BinaryExpressionOperator
		- <<readonly>> operandValueTypeGuard: InternalValueRepresentationTypeguard<O>
		evaluate(expression: UnaryExpression, evaluationContext: EvaluationContext, wrapperFactories: WrapperFactoryProvider, strategy: EvaluationStrategy, validationContext: ValidationContext | undefined): T | undefined
		polarsEvaluate(expression: UnaryExpression, evaluationContext: EvaluationContext, wrapperFactories: WrapperFactoryProvider, strategy: EvaluationStrategy, validationContext: ValidationContext | undefined): polars.Expr | undefined
		# {abstract} doEvaluate(operandValue: O, expression: UnaryExpression, context: ValidationContext | undefined): T | undefined
		# polarsDoEvaluate(_operand: polars.Expr, expression: UnaryExpression, context: ValidationContext): polars.Expr | undefined
		}

		interface PolarsOperatorEvaluator<E extends UnaryExpression | BinaryExpression | TernaryExpression> {
				<<readonly>> operator: E['operator']
				polarsEvaluate(expression: E, evaluationContext: EvaluationContext, wrapperFactories: WrapperFactoryProvider, strategy: EvaluationStrategy, validationContext: ValidationContext | undefined): polars.Expr | undefined
			}
		PolarsOperatorEvaluator <|.. DefaultBinaryOperatorEvaluator
		PolarsOperatorEvaluator <|.. DefaultUnaryOperatorEvaluator

		interface OperatorEvaluator<E extends UnaryExpression | BinaryExpression | TernaryExpression> {
				<<readonly>> operator: E['operator']
				evaluate(expression: E, evaluationContext: EvaluationContext, wrapperFactories: WrapperFactoryProvider, strategy: EvaluationStrategy, validationContext: ValidationContext | undefined): InternalValueRepresentation | undefined
			}
		OperatorEvaluator <|-- PolarsOperatorEvaluator

		interface OperatorEvaluatorRegistry {
				unary: Record<UnaryExpressionOperator,PolarsOperatorEvaluator<UnaryExpression>>
				binary: Record<BinaryExpressionOperator, PolarsOperatorEvaluator<BinaryExpression>>
			}

		interface OperatorTypeComputerRegistry {
				unary: Record<UnaryExpressionOperator, UnaryOperatorTypeComputer>
				binary: Record<BinaryExpressionOperator, BinaryOperatorTypeComputer>
			}
		class DefaultOperatorEvaluatorRegistry implements OperatorEvaluatorRegistry {
				DefaultOperatorEvaluatorRegistry(valueTypeProvider: ValueTypeProvider)
				- <<readonly>> valueTypeProvider: ValueTypeProvider
				unary: Record<UnaryExpressionOperator, UnaryOperatorTypeComputer>
				binary: Record<BinaryExpressionOperator, BinaryOperatorTypeComputer>
			}
		DefaultOperatorEvaluatorRegistry "1" -- "1" AdditionOperatorEvaluator: "'+'"
		DefaultOperatorEvaluatorRegistry "1" -- "1" RoundOperatorEvaluator: "'round'"
		@enduml
	\end{plantuml}
	\caption{Assuming the only operations were \Verb|round| and \Verb|plus|, this is how the Evaluators would be structured}
	\label{fig:evaluators_class_diagram}
\end{figure}


% TODO:
% @startuml
% ->BlockExecutor: execute()
% BlockExecutor -> AbstractBlockExecutor: execute()
% AbstractBlockExecutor -> PolarsTableTransformer: doExecute()
% PolarsTableTransformer -> PolarsTransformExecutor: new PolarsTransformExecutor()
% PolarsTransformExecutor -> PolarsTableTransformer: PolarsTableTransformer
% PolarsTableTransformer -> TransformExecutor: executeTransform()
% TransformExecutor -> PolarsTransformExecutor: doExecuteTransform()
% PolarsTransformExecutor -> : polarsEvaluateExpression()
% -> PolarsTransformExecutor: polars.polarsExpr
% PolarsTransformExecutor -> PolarsTableTr: idk
% @enduml

- Operator type calculators were not changed
- they dont reflect the actual types of the data during runtime anymore.
- they still prevent the user from doing illegal stuff.




\section{SQLiteLoader}
- again, create abstract class and move ts implementation into \Verb|TsSQLiteLoader|
- \Verb|SQLiteLoader<T>| has a general implementation for loading sqlite data utilising methods
- generateDropTableStatement
- generateCreateTableStatement
- use sqlvisitor to get column definitions
- generateInsertTableStatement
- use `df.rows`
- map over rows
- zip values in row with their valuetype obtained -> use sqlvisitor to get sql formatted representation of the value
- join all values into a string for each row
- join all rows into a valid sql statement
- return
- add polars functionality with \Verb|PolarsSQLiteLoaderExecutor|
- \Verb|PolarsSQLiteLoaderExecutor| and \Verb|TsSQLLoader| don't override the default implementation

\subsection{Rust stuff}
- we want to evaluate the extensibility of the polars backend
- create a extenal rust library with typescript interface via napi-package-template: \Verb|sqlite-loader-rust|
- use the rust version of polars inside the rust library
- napi functions cannot have dataframe as a parameter %TODO: why
- export dataframe into an arrow ipc file on disk.
- call \Verb|loadSqlite|
- context (including the logger, is lost)

\subsubsection{Ecosystem overview}
- rusqlite: no arrow support, but works well, can write
- arrow\_adbc: rust implementation is not there yet, it only has a dummy driver (not sqlite or postgres), requires dynamic linking of c libraries,
- connector\_arrow: built in rust, uses the arrow crate under the hood, supports many backends (postgres, duckdb, etc.), only sqlite implemented because prototype.

- rust:
- in case of unrecoverable error, use napi's errors to throw an error in the typescript code. include messages by library errors.
- use arrow::FileReader to read the ipc file into a BatchRecord iterator, because tables can be comprised of multiple batchrecords
- use rusqlite library to create a sqlite connection
- pass connection to connector\_arrow,
- use \Verb|SQLiteConnection|'s methods \Verb|table_drop| and \Verb|table_create| (get the schema from the first batch)
- from connection, use \Verb|append| to prepare an appender for the table
- append all batches
- finish appender





\begin{figure}
	\begin{plantuml}
		@startuml
		interface BlockExecutorClass<T extends BlockExecutor> {
				<<readonly>> type: string
			}
		class RustSQLiteLoaderExecutor implements BlockExecutorClass {
		+ {static} <<readonly>> type: 'RustSQLiteLoader'
		# executeLoad(table: PolarsTable, file: string, tableName: string, dropTable: boolean, context: ExecutionContext): Result<None>
		}
		class PolarsSQLiteLoaderExecutor implements BlockExecutorClass {
		+ {static} <<readonly>> type: 'PolarsSQLiteLoader'
		}
		class TsSQLiteLoaderExecutor implements BlockExecutorClass {
		+ {static} <<readonly>> type: 'TsSQLiteLoader'
		}
		abstract class SQLiteLoaderExecutor<T extends Table> {
		doExecute(table: T, context:ExecutionContext): Result<None>
		# {abstract} executeLoad(table: T, file: string, tableName: string, dropTable: boolean, context: ExecutionContext): Result<None>
		}
		SQLiteLoaderExecutor <|-- RustSQLiteLoaderExecutor: SQLiteLoader<PolarsTable>
		SQLiteLoaderExecutor <|-- PolarsSQLiteLoaderExecutor: SQLiteLoader<PolarsTable>
		SQLiteLoaderExecutor <|-- TsSQLiteLoaderExecutor: SQLiteLoader<TsTable>
		abstract class AbstractBlockExecutor<I extends IOType, O extends IOType> implements BlockExecutor {
		+ {abstract} doExecute(input: IOTypeImplementation<I\>, context: ExecutionContext): Result<IOTypeImplementation<O>\>
		}
		AbstractBlockExecutor <|-- SQLiteLoaderExecutor: AbstractBlockExecutor<IOType.TABLE, IOType.NONE>
		@enduml
	\end{plantuml}
	\caption{The Executors for SQLiteLoader}
	\label{fig:sqliteloaderexecutor_uml}
\end{figure}





