\chapter{Implementation}
\label{chapter:Implementation}

\section{Type Conversion}
- polars has its own type system not compatible with Jayvee valuetypes
- need for conversion between the two
- jayvee also has InternalValueRepresentation (stuff that expressions can evaluate to)
- wrong apporach:
- add the polars datatypes to internalvaluerepresentation
- they do not contain actual data, they are values representing types
- tried to do strategy on valuetypeproviders, didn't work
- right approach:
- jayvee is able to convert between valuetypes and polars datatypes when required
- dtype -> vtype: add \Verb|fromPolarsDType| method to \Verb|ValueTypeProvider|. unsupported plds throw an error.
- unsupported: pl.Categorical, pl.Date, pl.DateTime, pl.List, pl.Null, pl.Struct
- vtype -> dtype: add \Verb|toPolarsDataType| method to interface \Verb|ValueType|. unsupported vts return undefined.
- unsupported: EmptyCollection, collection(if inner is unsupported), valuetype-assignment, transform, regex, constraint, cell-range

- InternalValueRepresentation
- gets new typeguards
- prev: could only be used to narrow down internalvaluerepresentation it is
- now: unknwon types can be tested
- pl.Expr should be an atomicinternalvaluerepresentation but is kept seperate for allow the ts backend to coexist


\section{Table}
\subsection{abstract Table}
Jayvee implements \Verb{IOTypeImplementation<IOType.TABLE>} in \Verb{libs/execution/src/lib/types/io-types/table.ts}.
To increase clarity, the abstract \Verb|TableColumn| class and its subclasses \Verb|PolarsTableColumn| and \Verb|TsTableColumn| are moved into their own file \Verb|table-column.ts|.
\Verb|Table| defines defines abstract methods for its subclasses to implement and directly implements general behaviour in static methods. %TODO?: code snippet here?
\begin{figure}
	\begin{plantuml}
		@startuml
		abstract class Table {
		{abstract} <<getter>> nRows(): number
			{abstract} <<getter>>  nColumns(): number
			{abstract} <<getter>> columns(): ReadonlyArray<TableColumn>
			{abstract} withColumn(column: TableColumn): Table
			{abstract} hasColumn(name: string): boolean
			{abstract} getColumn(name: string): TableColumn | undefined
			{abstract} getRow(id: number): TableRow
			{abstract} clone(): Table
			{abstract} acceptVisitor<R>(visitor: IoTypeVisitor<R>): R
			{abstract} isPolars(): this is PolarsTable
			{abstract} isTypescript(): this is TsTable
			{static} generateDropTableStatement(tableName: string): string
			{abstract} generateInsertValuesStatement(tableName: string): string;
		{abstract} generateCreateTableStatement(tableName: string): string;
		}
		@enduml
	\end{plantuml}
	\caption{The class diagram of the \Verb{Table} class}
	\label{fig:table_uml}
\end{figure}

\subsubsection{changes compared to old table}
- The \Verb|addColumn| method was replaced with the \Verb|withColumn| metod
- \Verb|isPolars| and \Verb|isTypescript| typeguards were added
- utilised the \Verb|get| keyword for \Verb|getNumberOfColumns|


\subsection{PolarsTable}
\Verb|PolarsTable| extends \Verb|Table| and thereby also implements \Verb|IOTypeImplementation<IOType.Table>|.
\begin{figure}
	\begin{plantuml}
		@startuml
		class PolarsTable {
				-df: polars.DataFrame
				-valueTypeProvider: ValueTypeProvider
				<<getter>> nRows(): number
				<<getter>> nColumns(): number
				<<getter>> columns(): readonly PolarsTableColumn[]
				getTypes(): ValueType[]
				generateInsertValuesStatement(tableName: string): string
				generateCreateTableStatement(tableName: string): string
				withColumn(column: PolarsTableColumn): PolarsTable
				withColumnFromInternal(expr: PolarsInternal): PolarsTable
				hasColumn(name: string): boolean
				getColumn(name: string): PolarsTableColumn | undefined
				getRow(id: number): TableRow
				clone(): PolarsTable
				acceptVisitor<R>(visitor: IoTypeVisitor<R>): R
				isPolars(): this is PolarsTable
				isTypescript(): this is TsTable
				toString(): string
				writeIpc(options?: WriteIPCOptions): Buffer
				writeIpcTo(destination: string | Writable, options?: WriteIPCOptions): void
			}
		@enduml
	\end{plantuml}
	\caption{The class diagram of the \Verb{PolarsTable} class}
	\label{fig:polarstable_uml}
\end{figure}

It wraps the \Verb|polars.DataFrame| class and uses its methods to implement the abstract methods from \Verb|Table|, except with the general abstract types like \Verb|TableColumn| or \Verb|Table| replaced with types interacting with polars like \Verb|PolarsTable| or \Verb|PolarsTableColumn|.

\subsubsection{ValueTypeProvider}
This tells the jayvee interpreter jayvee specific type a value has.
This information is saved on a per column basis in the typescript backend.
The polars backend cannot do this, because the polars has its own valuetype system.
The Valuetype will have to be reinferred anytime a column is requested. %FIXME: getColumn() is called.

\begin{listing}
	\begin{minted}{typescript}
override withColumn(column: PolarsTableColumn): PolarsTable {
  const ndf = this.df.withColumn(column.series);
  return new PolarsTable(ndf, this.valueTypeProvider);
}
	\end{minted}
	\caption{An exemplary implementation in PolarsTable}
	\label{lst:polarstable_impl_example}
\end{listing}

\section{TableColumn}
Originally \Verb|TableColumn| was just %FIXME: "just" bad
an interface (see \ref{lst:table_column_interface})
\begin{listing}
	\begin{minted}{typescript}
interface TableColumn<
  T extends InternalValueRepresentation = InternalValueRepresentation,
> {
  values: T[];
  valueType: ValueType;
}
	\end{minted}
	\caption{The old implementation of TableColum}
	\label{lst:table_column_interface}
\end{listing}


Now, we use the same approach as with the tables, by creating an abstract superclass \Verb|TableColumn| (see \ref{fig:tablecolumn_uml}) that both \Verb|TsTableColumn|, with the old functionality, and \Verb|PolarsTableColumn| implement.

\begin{figure}
	\begin{plantuml}
		@startuml
		abstract class TableColumn{
				{abstract} <<getter>> valueType(): ValueType
					{abstract} <<getter>> length(): number
					{abstract} <<getter>> name(): string
					{abstract} <<setter>> name(newName: string)
				{abstract} nth(n: number): InternalValueRepresentation | undefined | null
					{abstract} clone(): TableColumn
					{abstract} isPolars(): this is PolarsTableColumn
					{abstract} isTypescript(): this is TsTableColumn
			}
		@enduml
	\end{plantuml}
	\caption{The \Verb|TableColumn| class diagram}
	\label{fig:tablecolumn_uml}
\end{figure}

\begin{figure}
	\begin{plantuml}
		@startuml
		class PolarsTableColumn {
				-_valueType: ValueType;
				-_series: polars.Series
				PolarsTableColumn(_series: Series, valueType: ValueType | ValueTypeProvider)
				<<getter>> valueType(): ValueType
				<<getter>> series(): Readonly<pl.Series>
				<<getter>> length(): number
				<<getter>> name(): string
				<<setter>> name(newName: string)
				nth(n: number): InternalValueRepresentation | undefined | null
				clone(): PolarsTableColumn
				isPolars(): this is PolarsTableColumn
				isTypescript(): this is TsTableColumn
			}
		@enduml
	\end{plantuml}
	\caption{The \Verb|PolarsTableColumn| class diagram}
	\label{fig:polastablecolumn_uml}
\end{figure}

- The constructor accepts both valuetype and valuetypeProvider
- if it's a valuetypeprovider the valuetype is inferred from the series dtype with the \Verb{fromPolarsDType} method.
- \Verb|nth| has to cast \Verb|any| to \Verb|InternalValueRepresentation| using \Verb|INTERNAL_VALUE_REPRESENTATION_TYPEGUARD| (new).
- it return \Verb|null| in case of the value being \Verb|null|
- most methods map more ot less directly onto series methods.

- the \Verb|TsTableColumn| implementation is also new
- now it has a \Verb|name| attribute.
% maybe TODO?: plantuml diag.
- compared to polarstablecolumn:
- clone is hacky
- everything gets serialized to json -> deserialize into object -> reassert type information
- this is because normal nodejs deep clone looses type information
- push and drop are supported, because they are required by the typescript blocks


\section{TableInterpreter}
- same approach as always (strategy).
- move previous implementation into \Verb|TsTableInterpreter|
- create abstract class \Verb|TableInterpreter|
- create new class \Verb|PolarsTableInterpreter|
- \Verb|toPolarsDataTypeWithLogs| is its own mehtod to enable code sharing with other table blocks.
- can't be in language-server because circular dependency
- uses the already present \Verb|ColumnDefintionEntry|


\begin{figure}
	\begin{plantuml}
		@startuml
		abstract class TableInterpeter {
		doExecute(inputSheet: Sheet, context: R.ExecutionContext): Promise<R.Result<R.Table>>
		# {abstract} constructAndValidateTable(sheet: Sheet, header: boolean, columnEntries: ColumnDefinitionEntry[], context: ExecutionContext): Table
		#deriveColumnDefinitionEntriesWithoutHeader(columnDefinitions: ValuetypeAssignment[], context: ExecutionContext): ColumnDefinitionEntry[]
		#deriveColumnDefinitionEntriesFromHeader(columnDefinitions: ValuetypeAssignment[], headerRow: string[], context: ExecutionContext): ColumnDefinitionEntry[]
		#parseAndValidateValue(value: string, valueType: ValueType, context: ExecutionContext): InternalValueRepresentation | undefined
		}
		@enduml
	\end{plantuml}
	\caption{}
	\label{fig:tableinterpreter_uml}
\end{figure}

\begin{figure}
	\begin{plantuml}
		@startuml
		class PolarsTableInterpreterExecutor {
		+ {static} <<readonly>> type: 'PolarsTableInterpreter' = 'PolarsTableInterpreter';
		# constructAndValidateTable(sheet: Sheet, header: boolean, columnEntries: ColumnDefinitionEntry[], context: ExecutionContext): PolarsTable
		- constructSeries(rows: readonly (readonly string[])[], columnEntry: ColumnDefinitionEntry, context: ExecutionContext): pl.Series
		}
		@enduml
	\end{plantuml}
	\caption{}\label{fig:polarstableinterpreter_uml}
\end{figure}



\section{TableTransformer}
- again strategy.
- steps:
1. check input coluns exist
2. create executor
3. check input columns match the transform input types.
3.1 compare the nth input column type to the nth transform input type and check with \Verb|isConvertibleTo|
3.1 return variableToColumnMap (varname -> columnexpr)
%maybee TODO: listing
4. execute the transform with the variabletocolumnmap -> returns polars expr that will perform the transform if applied to a table.
- wierd naming is to remain similar to the typescript implementation
5. extend the expression to include a renaming of the new column to \Verb|outputColumn|
6. apply the expression to the input table and return the resulting table

\subsection{Transforms}
- again strategy.
- previos tranform execution
1. pretend new table with input columns
2. execute expression for each row oth that (pretend) table
3. add resulting column (transforms only allow for one result): if outputname is the same as another column that one gets replaced

\subsubsection{Expressions}
- there is no \Verb|ExpressionEvaluator| class, a function \Verb|evaluateExpression|
- strategy pattern, the way we did it previously,is out.
- directly modifying the the values from the dataframe would require converting it back into a js datastructure, apply the expression, create new dataframe -> SLOW!
- utilise \Verb|polars.Expr|, which describe changes made to a polars DataFrame.
- add new method \Verb|polarsEvaluateExpression| that replicates the structure of \Verb|evaluateExpression|
- 1. free variable -> retrieve from context, if InternalValueRepresentation wrap in pl.lit and return.
- 2. literal -> wrap in pl.lit and return
- 3. other -> get evaluator from context / DefaultOperatorRegistry, evaluateExpression, return resulting pl.Expr or undefined
- this snippet \ref{lst:pl_expr_example} multiplies the values in column "a" with those in column "b".
\begin{listing}
	\begin{minted}{typescript}
const newDataFrame = dataFrame.withColumn(pl.col("a").mul(pl.col("b")))
	\end{minted}
	\caption{How to multiply column "a" and "b" of a dataframe}
	\label{lst:pl_expr_example}
\end{listing}
- instead of calculating the new values directly, evaluators now return pl.Expression
\begin{listing}
	\begin{minted}{typescript}
export function polarsEvaluateExpression(
  expression: Expression | undefined,
  evaluationContext: EvaluationContext,
  wrapperFactories: WrapperFactoryProvider,
  context: ValidationContext | undefined = undefined,
  strategy: EvaluationStrategy = EvaluationStrategy.LAZY,
): PolarsInternal | undefined {
  if (expression === undefined) {
    return undefined;
  }
  if (isExpressionLiteral(expression)) {
    if (isFreeVariableLiteral(expression)) {
      const fv = evaluationContext.getValueFor(expression);
      if (INTERNAL_VALUE_REPRESENTATION_TYPEGUARD(fv)) {
        return pl.lit(fv);
      }
      return fv;
    } else if (isValueLiteral(expression)) {
      const lit = evaluateValueLiteral(
        expression,
        evaluationContext,
        wrapperFactories,
        context,
        strategy,
      );
      if (lit === undefined) {
        return undefined;
      }
      return pl.lit(lit);
    }
    assertUnreachable(expression);
  }
  const evaluator = getEvaluator(expression, evaluationContext);

  return evaluator.polarsEvaluate(
    expression,
    evaluationContext,
    wrapperFactories,
    strategy,
    context,
  );
}
	\end{minted}
	\caption{pseudocode}
	\label{lst:pseudocode}
\end{listing}


\begin{figure}
	\begin{plantuml}
		class AdditionOperatorEvaluator {
				AdditionOperatorEvaluator()
				doEvaluate(left: number, right: number): number
				polarsDoEvaluate(left: polars.Expr, right: polars.Expr): polars.Expr
			}

		class RoundOperatorEvaluator {
				RoundOperatorEvaluator()
				doEvaluate(operandValue: number): number
				polarsDoEvaluate(operand: polars.Expr): polars.Expr
			}
		DefaultUnaryOperatorEvaluator <|-- RoundOperatorEvaluator: DefaultUnaryOperatorEvaluator<number, number>

		abstract class DefaultBinaryOperatorEvaluator<L extends InternalValueRepresentation, R extends InternalValueRepresentation, T extends InternalValueRepresentation> {
		DefaultBinaryOperatorEvaluator(operator, leftValueTypeGuard, rightValueTypeGuard)
		+ <<readonly>> operator: BinaryExpressionOperator
		- <<readonly>> leftValueTypeGuard: InternalValueRepresentationTypeguard<L>
		- <<readonly>> rightValueTypeGuard: InternalValueRepresentationTypeguard<R>
		evaluate(expression: BinaryExpression, evaluationContext: EvaluationContext, wrapperFactories: WrapperFactoryProvider, strategy: EvaluationStrategy, validationContext: ValidationContext | undefined): T | undefined
		polarsEvaluate(expression: BinaryExpression, evaluationContext: EvaluationContext, wrapperFactories: WrapperFactoryProvider, strategy: EvaluationStrategy, validationContext: ValidationContext | undefined): polars.Expr | undefined
		# {abstract} doEvaluate(leftValue: L, rightValue: R, expression: BinaryExpression, context: ValidationContext | undefined): T | undefined
		# polarsDoEvaluate(_left: polars.Expr, _right: polars.Expr, expression: BinaryExpression, context: ValidationContext): polars.Expr | undefined
		}
		DefaultBinaryOperatorEvaluator <|-- AdditionOperatorEvaluator: DefaultBinaryOperatorEvaluator<number, number, number>

		abstract class DefaultUnaryOperatorEvaluator<0 extends InternalValueRepresentation T extends InternalValueRepresentation> {
		DefaultUnaryOperatorEvaluator(operator: string, operandValueTypeGuard: InternalValueRepresentationTypeguard<O>)
		+ <<readonly>> operator: BinaryExpressionOperator
		- <<readonly>> operandValueTypeGuard: InternalValueRepresentationTypeguard<O>
		evaluate(expression: UnaryExpression, evaluationContext: EvaluationContext, wrapperFactories: WrapperFactoryProvider, strategy: EvaluationStrategy, validationContext: ValidationContext | undefined): T | undefined
		polarsEvaluate(expression: UnaryExpression, evaluationContext: EvaluationContext, wrapperFactories: WrapperFactoryProvider, strategy: EvaluationStrategy, validationContext: ValidationContext | undefined): polars.Expr | undefined
		# {abstract} doEvaluate(operandValue: O, expression: UnaryExpression, context: ValidationContext | undefined): T | undefined
		# polarsDoEvaluate(_operand: polars.Expr, expression: UnaryExpression, context: ValidationContext): polars.Expr | undefined
		}

		interface PolarsOperatorEvaluator<E extends UnaryExpression | BinaryExpression | TernaryExpression> {
				<<readonly>> operator: E['operator']
				polarsEvaluate(expression: E, evaluationContext: EvaluationContext, wrapperFactories: WrapperFactoryProvider, strategy: EvaluationStrategy, validationContext: ValidationContext | undefined): polars.Expr | undefined
			}
		PolarsOperatorEvaluator <|.. DefaultBinaryOperatorEvaluator
		PolarsOperatorEvaluator <|.. DefaultUnaryOperatorEvaluator

		interface OperatorEvaluator<E extends UnaryExpression | BinaryExpression | TernaryExpression> {
				<<readonly>> operator: E['operator']
				evaluate(expression: E, evaluationContext: EvaluationContext, wrapperFactories: WrapperFactoryProvider, strategy: EvaluationStrategy, validationContext: ValidationContext | undefined): InternalValueRepresentation | undefined
			}
		OperatorEvaluator <|-- PolarsOperatorEvaluator

		interface OperatorEvaluatorRegistry {
				unary: Record<UnaryExpressionOperator,PolarsOperatorEvaluator<UnaryExpression>>
				binary: Record<BinaryExpressionOperator, PolarsOperatorEvaluator<BinaryExpression>>
			}

		interface OperatorTypeComputerRegistry {
				unary: Record<UnaryExpressionOperator, UnaryOperatorTypeComputer>
				binary: Record<BinaryExpressionOperator, BinaryOperatorTypeComputer>
			}
		class DefaultOperatorEvaluatorRegistry implements OperatorEvaluatorRegistry {
				DefaultOperatorEvaluatorRegistry(valueTypeProvider: ValueTypeProvider)
				- <<readonly>> valueTypeProvider: ValueTypeProvider
				unary: Record<UnaryExpressionOperator, UnaryOperatorTypeComputer>
				binary: Record<BinaryExpressionOperator, BinaryOperatorTypeComputer>
			}
		DefaultOperatorEvaluatorRegistry "1" -- "1" AdditionOperatorEvaluator: "'+'"
		DefaultOperatorEvaluatorRegistry "1" -- "1" RoundOperatorEvaluator: "'round'"
	\end{plantuml}
	\caption{Assuming the only operations were \Verb|round| and \Verb|plus|, this is how the Evaluators would be structured}
	\label{fig:evaluators_class_diagram}
\end{figure}


% TODO:
% @startuml
% ->BlockExecutor: execute()
% BlockExecutor -> AbstractBlockExecutor: execute()
% AbstractBlockExecutor -> PolarsTableTransformer: doExecute()
% PolarsTableTransformer -> PolarsTransformExecutor: new PolarsTransformExecutor()
% PolarsTransformExecutor -> PolarsTableTransformer: PolarsTableTransformer
% PolarsTableTransformer -> TransformExecutor: executeTransform()
% TransformExecutor -> PolarsTransformExecutor: doExecuteTransform()
% PolarsTransformExecutor -> : polarsEvaluateExpression()
% -> PolarsTransformExecutor: polars.polarsExpr
% PolarsTransformExecutor -> PolarsTableTr: idk
% @enduml

- Operator type calculators were not changed
- they dont reflect the actual types of the data during runtime anymore.
- they still prevent the user from doing illegal stuff.




\section{SQLiteLoader}
- again, create abstract class and move ts implementation into \Verb|TsSQLiteLoader|
- \Verb|SQLiteLoader<T>| has a general implementation for loading sqlite data utilising methods
- generateDropTableStatement
- generateCreateTableStatement
- use sqlvisitor to get column definitions
- generateInsertTableStatement
- use `df.rows`
- map over rows
- zip values in row with their valuetype obtained -> use sqlvisitor to get sql formatted representation of the value
- join all values into a string for each row
- join all rows into a valid sql statement
- return
- add polars functionality with \Verb|PolarsSQLiteLoaderExecutor|
- \Verb|PolarsSQLiteLoaderExecutor| and \Verb|TsSQLLoader| don't override the default implementation

\subsection{Rust stuff}
- we want to evaluate the extensibility of the polars backend
- create a extenal rust library with typescript interface via napi-package-template: \Verb|sqlite-loader-rust|
- use the rust version of polars inside the rust library
- napi functions cannot have dataframe as a parameter %TODO: why
- export dataframe into an arrow ipc file on disk.
- call \Verb|loadSqlite|
- context (including the logger, is lost)

\subsubsection{Ecosystem overview}
- rusqlite: no arrow support, but works well, can write
- arrow\_adbc: rust implementation is not there yet, it only has a dummy driver (not sqlite or postgres), requires dynamic linking of c libraries,
- connector\_arrow: built in rust, uses the arrow crate under the hood, supports many backends (postgres, duckdb, etc.), only sqlite implemented because prototype.

- rust:
- in case of unrecoverable error, use napi's errors to throw an error in the typescript code. include messages by library errors.
- use arrow::FileReader to read the ipc file into a BatchRecord iterator, because tables can be comprised of multiple batchrecords
- use rusqlite library to create a sqlite connection
- pass connection to connector\_arrow,
- use \Verb|SQLiteConnection|'s methods \Verb|table_drop| and \Verb|table_create| (get the schema from the first batch)
- from connection, use \Verb|append| to prepare an appender for the table
- append all batches
- finish appender





\begin{figure}
	\begin{plantuml}
		@startuml
		interface BlockExecutorClass<T extends BlockExecutor> {
				<<readonly>> type: string
			}
		class RustSQLiteLoaderExecutor implements BlockExecutorClass {
		+ {static} <<readonly>> type: 'RustSQLiteLoader'
		# executeLoad(table: PolarsTable, file: string, tableName: string, dropTable: boolean, context: ExecutionContext): Result<None>
		}
		class PolarsSQLiteLoaderExecutor implements BlockExecutorClass {
		+ {static} <<readonly>> type: 'PolarsSQLiteLoader'
		}
		class TsSQLiteLoaderExecutor implements BlockExecutorClass {
		+ {static} <<readonly>> type: 'TsSQLiteLoader'
		}
		abstract class SQLiteLoaderExecutor<T extends Table> {
		doExecute(table: T, context:ExecutionContext): Result<None>
		# {abstract} executeLoad(table: T, file: string, tableName: string, dropTable: boolean, context: ExecutionContext): Result<None>
		}
		SQLiteLoaderExecutor <|-- RustSQLiteLoaderExecutor: SQLiteLoader<PolarsTable>
		SQLiteLoaderExecutor <|-- PolarsSQLiteLoaderExecutor: SQLiteLoader<PolarsTable>
		SQLiteLoaderExecutor <|-- TsSQLiteLoaderExecutor: SQLiteLoader<TsTable>
		abstract class AbstractBlockExecutor<I extends IOType, O extends IOType> implements BlockExecutor {
		+ {abstract} doExecute(input: IOTypeImplementation<I\>, context: ExecutionContext): Result<IOTypeImplementation<O>\>
		}
		AbstractBlockExecutor <|-- SQLiteLoaderExecutor: AbstractBlockExecutor<IOType.TABLE, IOType.NONE>
		@enduml
	\end{plantuml}
	\caption{The Executors for SQLiteLoader}
	\label{fig:sqliteloaderexecutor_uml}
\end{figure}





