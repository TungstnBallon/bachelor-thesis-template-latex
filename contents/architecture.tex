\chapter{Architecture}
\label{chapter:Architecture}

In this chapter we give an overview over the defiened reqirements.
Then, we describe the new architecture introduced into the jayvee interpreter.

\section{Requirements}
\label{section:Requirements}

We follow the established practice of differentiating between functional and non functional requirements.
These requirements have been evaluated for completenes, consistency and feasability.

\subsection{Functional Requirements}
\label{subsection:FunctionalRequirements}

\begin{enumerate}
	\item[FR-1] Tables in Jayvee are represented with a data format fulfilling these requirements:
	      \begin{description}
		      \item[standardized] Increases interoperability.
		      \item[in-memory] Jayvee needs to transform the data, so it must be in memory.
		      \item[columnar] See \ref{section:column_vs_row} for the advantages of columnar formats over row-oriented ones.
	      \end{description}
	\item[FR-2] Execute the electric vehicles example without errors.
	      The resulting table must be the same as prevoius.
	      The tests succeeding %FIXME
	      is explicitly not a requirement.
	      We aim to create a prototype, not a mature implementation.
	\item[FR-3]\label{fr:runtime} We must be able to (de)activate the new features at runtime.
	      This makes comparing the new features easier. %FIXME
	\item[FR-4] Should it be necessary to write code in a language other than typescript, this code must be placed in an external library usable from typesript.
	      This ensures usability and increases maintainability by for other developers.
\end{enumerate}

% Tables are the central way Jayvee represent's data.
% The other types like \Verb|TextFile| or \Verb|Sheet| mostly exists to be parsed into tables.
% Hence % TODO: ?
% we shall focus on how to efficiently represent tables in memory.
% Since Jayvee's \Verb|TableTransformer| work on columns and not rows, the advantages of the columnar format outlined in %TODO: ref
% lend themselves well to jayvee.
% Jayvee needs manipulate the data, so data needs to be stored in memory not on disk.
% 1. This leads to the requirement that \emph{tables are represented with a columnar, in-memory data layout}.
%
% The goal of this thesis is not to create a fully mature implementation of this new format, but rather to prototype an integration and evaluate the results of this migration.
% However to accurately evaluate the changes, the core functionality of jayvee (parse data into table, apply function to columns of that table, export table) needs to be preserved.
% 2. \emph{Core functionality is maintained}.
% This includes that tables can still be created in the same ways (\Verb|TableIntepreter|) and exported with the same blocks (\Verb|SQLiteLoader|) (\Verb|PostresLoader|).
% 3. \emph{Arithmetic operations work in transforms}.

% 4. Should it be necessary to write code in a language other than typescript, this code must be placed in an external library usable from typesript.
% This ensures usability and increases maintainability by for other developers.

% 5. To make evaluation easier the new implementation must be choosable with a commandline flag \emph{at runtime}.

\subsection{Non Functional Requirements}
\label{subsection:NonFunctionalRequirements}

\begin{enumerate}
	\item[NFR-1] The main goal of this thesis is to \emph{optimize} Jayvee's in-memory representation.
	      We expect this to result in either a decrease in the execution time for jayvee models, or an extension of the Jayvee interpreter's capabilities.
	\item[NFR-2] The source code is readable for non-rust developers
	\item[NFR-3] The new code generates log messages consistent to the existing ones.
	\item[NFR-4] The source code adheres to the project's code style.
	      This is enforced by running \Verb|npm run lint|.
	      In rust code we use the defaults from rustfmt and clippy.
\end{enumerate}

\section{Interpreter Overview}
\label{section:prev}

In this section, we will give an overview of how the interpreter executes a Jayvee pipeline.

Pipeline definitions in jayvee consist of a series of block definitions.
At runtime, the jayvee interpreter associates each block-definition with a class implementing the \Verb|BlockExecutor| interface.
These executors all have one input and one output, both of which implement the \Verb|IOTypeImplementation| interface.
An example for such an implementation is the \Verb|Table| class.
The interpreter executes these executors in the order specified in the \Verb|.jv| file.
The output of the previous block executor is always the input for the next.
% Since the TableTransformer is central to jayvee's functionality, we will explore it further %FIXME

One of Jayvee's core features is the transformation of tables using expressions.
Thus we will put special attention into how this works.

One of the classes implementing \Verb|BockExecutor| is \Verb|TableTransformerExecutor|.
It creates and executes the \Verb|TransformExecutor|, which evaluates the transform's expression expression for every row of the table and returns the resulting column.
This column is then added to the input table by \Verb|TableTransformer|

Expressions are evaluated by the \Verb|evaluateExpression| function.
Expressions with parameter(s) (unary, binary, ternary) have evaluator classes that implement the \Verb|OperatorEvaluator| interface.
The \Verb|evaluateExpression| function finds the correct evaluator with the help of the \Verb|OperatorEvaluatorRegistry|.

See \ref{fig:uml:overview} for an overview of this structure.


\begin{figure}
	\begin{plantuml}
		@startuml
		hide members

		interface BlockExecutor
		interface BlockExecutorClass

		interface IOTypeImplementation
		BlockExecutor  -  IOTypeImplementation: input
		BlockExecutor - IOTypeImplementation: output
		class Table implements IOTypeImplementation

		abstract class AbstractBlockExecutor implements BlockExecutor
		class TableTransformerExecutor extends AbstractBlockExecutor implements BlockExecutorClass

		class TransformExecutor
		TableTransformerExecutor -- TransformExecutor: creates and executes >

		interface OperatorEvaluator
		abstract class DefaultBinaryOperatorEvaluator implements OperatorEvaluator
		abstract class DefaultUnaryOperatorEvaluator implements OperatorEvaluator
		class AdditionOperatorEvaluator extends DefaultBinaryOperatorEvaluator
		class RoundOperatorEvaluator extends DefaultUnaryOperatorEvaluator

		interface OperatorEvaluatorRegistry
		class DefaultOperatorEvaluatorRegistry implements OperatorEvaluatorRegistry
		TransformExecutor -- OperatorEvaluatorRegistry: looks up ""operator"" >
		OperatorEvaluatorRegistry - OperatorEvaluator: maps ""operator"" to an implementation of >
		@enduml
	\end{plantuml}
	\caption{The general structure of the Jayvee interpreter. Many subclasses and implementations have been omitted for readabiltiy.}
	\label{fig:uml:overview}
\end{figure}


% \begin{figure}
% 	\begin{plantuml}
% 		@startuml
% 		hide empty members
%
% 		interface PipelineDefinition
% 		interface BlockDefinition
%
% 		interface BlockExecutor<I extends IOType, O extends IOType> {
% 				+execute(input: IOTypeImplementation<I\>, context: ExecutionContext): Result<IOTypeImplementation<O>>
% 			}
%
% 		interface BlockExecutorClass {}
%
% 		PipelineDefinition "1" *-- "many" BlockDefinition
% 		BlockDefinition "1" --> "1" BlockExecutor: interpreter finds fitting implementation %FIXME: fitting
%
% 		interface IOTypeImplementation<T extends IOType>
% 		IOTypeImplementation - BlockExecutor: input
% 		IOTypeImplementation - BlockExecutor: output
%
% 		class Table
% 		IOTypeImplementation <|.. Table : IOTypeImplementation<IOType.TABLE>
%
% 		abstract class AbstractBlockExecutor<I extends IOType, O extends IOType> implements BlockExecutor {
% 		+ {abstract} doExecute(input: IOTypeImplementation<I\>, context: ExecutionContext): Result<IOTypeImplementation<O\>>
% 		}
%
% 		class TableTransformerExecutor {
% 				+doExecute(input: Table, context: ExecutionContext): Result<Table>
% 			}
% 		AbstractBlockExecutor <|-- TableTransformerExecutor: AbstractBlockExecutor<IOType.TABLE, IOType.TABLE>
% 		BlockExecutorClass <|-- TableTransformerExecutor
% 		@enduml
% 	\end{plantuml}
% 	\caption{How \Verb|Table| fits into the interpreter} %FIXME
% 	\label{fig:prev_sit}
% \end{figure}

\section{General Idea}
\label{section:General Idea}

We replace the current implementation of tables in the jayvee interpreter with one based on the Apache Arrow framework \ref{section:arrow}.
% This includes creating a common interface for both the current TypeScript implementation and the new Arrow variant.
% Then we will adapt existing BlockExecutor implementations to take advantage of arrows

\begin{figure}
	\begin{plantuml}
		@startuml
		start
		:start interpreter;
		:parse model;
		if (parseOnly) then (yes)
		else (no)
		while (more pipeline)
		partition run pipelines {
				:sort blocks into execution order;
				while (more blocks)
				partition run block {
						partition get block exectutor {
								if (block has multiple executors) then (yes)
								if (usePolars) then (true)
								:pick polars executor;
								else (false)
								:pick typescript executor;
								endif
								else (no)
								:pick general executor;
								endif
							}
						:call exectutor;
						note
						<code>
						BlockExecutor<I extends IOType,O extends IOType>.execute(
						input: IOTypeImplementation<I>,
						context: ExectutionContext
						): Result<IOTypeImplementation<O>>
						</code>
						end note
						:save output as input for the next block;
					}
				endwhile
			}
		endwhile
		endif
		stop
		@enduml
	\end{plantuml}
	\caption{An activity diagram overview of the interpreter}
	\label{fig:interpreter_activity}
\end{figure}


\subsection{Possible implementations}
\label{subsection:arrow implementations}

In this section, we will discuss possible implementations of the arrow specification.

\subsubsection{Implementation from scratch}
\label{subsubsection:direct_implementation}
The most direct approach is a new implementation the Arrow specification.
This would have the advantage of having full control over the implementation.
However, it it not guaranteed that a sufficient ammount can be implemented within the timeframe of the thesis.
This implementation would likely perform worse than an existing, matured implementation, which is likely also be more correct.

An implementation from scratch is \emph{too big in scope} for a bachelor's thesis.

\subsubsection{Apache Arrow in TypeScript}
\label{subsubsection:arrow_in_js}
There is an Arrow library written in typescript \autocite{arrow:overview}, which is the lanugage of the Jayvee interpreter.
This implementation is comparable to those in other languages regarding supported datatypes, but is lags behind with support for other apache frameworks \autocite{arrow:status}, which takes away one of arrow's strengths.

\subsubsection{Polars}
\label{subsection:polars}
Polars is a high level api built on top of apache arrows, but it also offers useful abstractions like DataFrames, that hide the Arrow datatypes.
These abstractions make it easier for developers unfamiliar with Arrow to contribute to Jayvee.
Polars is written in rust, but offers a Java-/TypeScript \ac{API}, allowing us %FIXME: us
to access the speed of rust, %FIXME: citation + rewordig
while still remaining accessible to typescript developers.
For these reasons, we choose to build the new table implementaiton on top of polars.


\section{The strategy pattern}
The requirement to pick the implementation at runtime makes the strategy pattern really appealing. %FIXME: wording
%TODO: Describe strategy pattern more

\section{Type conversion}
\label{section:type_conversion}
Jayvee has a concept called ValueType, that represent Jayvee types, e.g. text, boolean or decimal.
They are useful because Jayvee types don't map directly to TypeScript types.
For example, when a value inside a table has the JavaScript type \Verb|number|, a ValueType is used to remember whether it's meant to be a Jayvee \Verb|integer| or Jayvee \Verb|decimal|.

Polars has the same system, except it's called DataType.
DataTypes are not compatible with ValueTypes, which leaves us with two possible approaches.
\begin{enumerate}
	\item \emph{Replace} ValueTypes with DataTypes.
	      We decided against this approach, because it forces the polars implementation at compile time, which breaks \ref{fr:runtime}.
	\item \emph{Convert} between ValueTypes and DataTypes when needed.
	      The TypesScript implementation can ignore this and keep using ValueTypes as before.
\end{enumerate}

For details on how this conversion mechanism is implemented, see \ref{subsection:TypeConversion}.

% Jayvee also defines a union type \Verb|InternalValueRepresentation| which aggregates %FIXME: aggregate
% all TypeScript types allowed in jayvee.
%
% This includes \Verb|string|, \Verb|number| and \Verb|boolean|.
%
% \subsection{Wrong Approach}
% At first we thought that polars' DataTypes were similar to \Verb|InternalValueRepresenation| and tried to add them to the union type.
% However pl.String does not contain an actual string it's just a symbol for the string type
%
% This happened because we did not understand the Difference between ValueTypes and InternalValueRepresentation


\section{Creating a Table implementation based on Polars}
\label{section:new_table}

The usual application of the strategy pattern would create an interface \autocite{Dooley2024} that both the old and the new table classes implement.
Instead, we utilise an abstract class, to allow for code-sharing between the table subclasses.
We can still define functionality for both subclasses using \emph{abstract methods}.

Jayvee already has a \Verb|Table| class that implements the \Verb|IOTypeImplementation<IOType.TABLE>| interface.
We move all of the functionality from \Verb{Table} to \Verb{TsTable} and create a new \emph{abstract} class \Verb|Table|.

\subsection{\Verb{abstract Table}}
This class implements the \Verb|IOTypeImplementation<IOType.TABLE>| interface to be allowed as an input / output for blocks.
It' methods are based on those of the original Table class.
See \ref{fig:uml:table} for a class diagram.

\subsubsection{Differences between the old Table and the new abstract Table}
The \Verb|addColumn| method was replaced with \Verb|withColumn|, the concrete differences are explained in \ref{subssubsection:impl:old_vs_new}.
Typeguards to distinguish the implementations, \Verb|isPolars| and \Verb|isTypescript|, were added.
Also, we replaced the \Verb|number_of_rows| proberty with getter method using the \Verb|get| keyword.

\begin{figure}
	\begin{plantuml}
		@startuml
		abstract class Table {
				{abstract} <<getter>> nRows(): number
					{abstract} <<getter>>  nColumns(): number
					{abstract} <<getter>> columns(): ReadonlyArray<TableColumn>
					{abstract} withColumn(column: TableColumn): Table
					{abstract} hasColumn(name: string): boolean
					{abstract} getColumn(name: string): TableColumn | undefined
					{abstract} getRow(id: number): TableRow
					{abstract} clone(): Table
					{abstract} acceptVisitor<R>(visitor: IoTypeVisitor<R>): R
					{abstract} isPolars(): this is PolarsTable
					{abstract} isTypescript(): this is TsTable
					{static} generateDropTableStatement(tableName: string): string
					{abstract} generateInsertValuesStatement(tableName: string): string
					{abstract} generateCreateTableStatement(tableName: string): string
			}
		@enduml
	\end{plantuml}
	\caption{The class diagram of the \Verb{Table} class}
	\label{fig:uml:table}
\end{figure}

\subsection{PolarsTable}
Polars' \Verb|DataFrame| already has table functionality, like the ability to add/remove/transform columns.
However, \Verb|DataFrame|'s methods aren't the same as those required by \Verb|Table|.
To solve this, we create a wrapper class \Verb|PolarsTable|, that extends \Verb|Table| and thereby implements \Verb|IOTypeImplementation<IOType.TABLE>|, allowing \Verb|PolarsTable| to be used as an input / output for block executors.
\Verb|PolarsTable| extends \Verb|Table|'s abstract methods by calling \Verb|DataFrames| methods, which is a characteristic of the \emph{adapter pattern} \autocite{Dooley2024}.
In the terminology of the adapter pattern, \Verb|Table| is the target, \Verb|PolarsTable| the adapter and \Verb|DataFrame| the adaptee.

A notable differences between the abstract methods of \Verb|Table| and their overrides in \Verb|PolarsTable| is that, when \Verb|PolarsTable| is
It is notable that when \Verb|Table| is parameter or return type in an abstract method in \Verb|Table|, the overriding method in \Verb|PolarsTable| replaced that with \Verb|PolarsTable|.
For example \mintedinline{typescript}{abstract clone(): Table} becomes \mintedinline{typescript}{override clone(): PolarsTable}.
This is legal %FIXME: maybe better term instead of legal
because \Verb|PolarsTable| is a subclass of \Verb|Table|.

In addition to the abstract methods from \Verb|Table|, \Verb|PolarsTable| also implements methods that take advantage of features not available in the TypeScript implementation.
\Verb|withColumnFormInternal| returns a new Table with the column resulting from the passed expression added.
\Verb|writeIpc| and \Verb|writeIpcTo| convert the table to the Arrow \ac{IPC} format, writing either into a Buffer or a File.

One of the negative consequences is that adding a column into the DataFrame is that the column's ValueType is lost, because the Dataframe uses polars' DataTypes.
This is problematic, because TableColumn expects a ValueType for it's constructor.
The solution is to convert the polars DataType of a column to a ValueType using the conversion mechanism in \ref{subsection:TypeConversion}.
Conversion requires a ValueTypeProvider, which is saved as one of PolarsTable's properties.

\Verb|PolarsTable| requires a \Verb|ValueTypeProvider|
to be passed to its contructor. See \ref{subsubsection:polarstablecolumn}.
See \ref{fig:uml:polarstable} for the class diagram.

\begin{figure}
	\begin{plantuml}
		@startuml
		class PolarsTable {
				-df: polars.DataFrame
				-valueTypeProvider: ValueTypeProvider
				PolarsTable(df, valueTypeProvider)
				<<getter>> nRows(): number
				<<getter>> nColumns(): number
				<<getter>> columns(): readonly PolarsTableColumn[]
				getTypes(): ValueType[]
				generateInsertValuesStatement(tableName: string): string
				generateCreateTableStatement(tableName: string): string
				withColumn(column: PolarsTableColumn): PolarsTable
				withColumnFromInternal(expr: polars.Expr): PolarsTable
				hasColumn(name: string): boolean
				getColumn(name: string): PolarsTableColumn | undefined
				getRow(id: number): TableRow
				clone(): PolarsTable
				acceptVisitor<R>(visitor: IoTypeVisitor<R>): R
				isPolars(): this is PolarsTable
				isTypescript(): this is TsTable
				toString(): string
				writeIpc(options?: WriteIPCOptions): Buffer
				writeIpcTo(destination: string | Writable, options?: WriteIPCOptions): void
			}
		@enduml
	\end{plantuml}
	\caption{The class diagram of the \Verb{PolarsTable} class}
	\label{fig:uml:polarstable}
\end{figure}

\subsection{Implementing Columns}
Polars represents columns with it's \Verb|Series| type.
Analogous to \Verb|Table| we create an abstract class \Verb|TableColumn| that has two subclasses, \Verb|TsTableColumn| and \Verb|PolarsTableColumn|

\subsubsection{\Verb{abstract TableColumn}}
Whereas \Verb|Table| replicates the old typescript method signatures, the new \Verb|TableColum| is closer to the Polars \Verb|Series| (see \ref{fig:uml:tablecolumn}).
The biggest change is that \Verb|TableColumn| does not have a generic specifing the type contained in the column (detailed explanation in \ref{subsubsection:polarstablecolumn}).
Another change is the name of the column being a part of the TableColumn class now.

% \begin{figure}
% 	\begin{plantuml}
% 		@startuml
% 		interface TableColumn<T extends InternalValueRepresentation>{
% 				+values: T[]
% 				+valueType: ValueType
% 			}
% 		@enduml
% 	\end{plantuml}
% 	\caption{The old \Verb|TableColumn|}
% 	\label{fig:uml:old_tablecolumn}
% \end{figure}

\begin{figure}
	\begin{plantuml}
		@startuml
		abstract class TableColumn{
				{abstract} <<getter>> valueType(): ValueType
					{abstract} <<getter>> length(): number
					{abstract} <<getter>> name(): string
					{abstract} <<setter>> name(newName: string)
				{abstract} nth(n: number): InternalValueRepresentation | undefined | null
					{abstract} clone(): TableColumn
					{abstract} isPolars(): this is PolarsTableColumn
					{abstract} isTypescript(): this is TsTableColumn
			}
		@enduml
	\end{plantuml}
	\caption{The \Verb|TableColumn| class diagram}
	\label{fig:uml:tablecolumn}
\end{figure}

\subsubsection{PolarsTableColumn}
\label{subsubsection:polarstablecolumn}
\Verb|PolarsTableColumn| wraps Polars' \Verb|Series|, so it's also an adapter, \Verb|TableColumn| the target and \Verb|Series| the adaptee.

Notably, \Verb|Series| does not have a generic type parameter which is why \Verb|PolarsTableColumn|'s \Verb|nth| returns \Verb|InternalValueRepresentation| instead of \Verb |T| .

\begin{figure}
	\begin{plantuml}
		@startuml
		class PolarsTableColumn {
				-_valueType: ValueType;
				-_series: polars.Series
				PolarsTableColumn(_series: Series, valueType: ValueType | ValueTypeProvider)
				<<getter>> valueType(): ValueType
				<<getter>> series(): Readonly<pl.Series>
				<<getter>> length(): number
				<<getter>> name(): string
				<<setter>> name(newName: string)
				nth(n: number): InternalValueRepresentation | undefined | null
				clone(): PolarsTableColumn
				isPolars(): this is PolarsTableColumn
				isTypescript(): this is TsTableColumn
			}
		@enduml
	\end{plantuml}
	\caption{The \Verb|PolarsTableColumn| class diagram}
	\label{fig:uml:polastablecolumn}
\end{figure}

\subsubsection{TsTableColumn}
A notable difference between \Verb|TsTableColumn| and \Verb|PolarsTableColumn| is the generic type parameter \Verb|T|.
This allows \Verb|nth|'s return type, to be more specific than the general \Verb|InternalValueRepresenation| of \Verb|PolarsTableColumn|.
Notably, \Verb|TsTableColum| has a generic type Parmeter \Verb|T|, whic allows the return type of \Verb|nth| to be a lot more specific than it's equivalent in \Verb|PolarsTableColumn|.

\begin{figure}
	\begin{plantuml}
		@startuml
		class TsTableColumn<T extends InternalValueRepresentation> {
				- name: string
				-_valueType: ValueType<T>;
				-_values: T[]
				TsTableColumn(_name, _valueType, _values)
				<<getter>> valueType(): ValueType
				<<getter>> length(): number
				<<getter>> name(): string
				<<setter>> name(newName: string)
				nth(n: number): T | undefined
				clone(): TsTableColumn
				isPolars(): this is PolarsTableColumn
				isTypescript(): this is TsTableColumn
				push(element: T)
				drop(index: number)
			}
		@enduml
	\end{plantuml}
	\caption{The \Verb|PolarsTableColumn| class diagram}
	\label{fig:uml:tstablecolumn}
\end{figure}



\subsection{How it fits together}
\begin{figure}
	\begin{plantuml}
		@startuml
		hide empty members
		interface IOTypeImplementation<T extends IOType = IOType> {
				+ioType: T
				+acceptVisitor<R>(vistor: IoTypeVisitor<R>): R
			}
		abstract class Table {
				+ioType: IOType.TABLE
			}
		IOTypeImplementation <|.. Table : IOtypeImplementation<IOType.TABLE>
		abstract class TableColumn {
			}
		class PolarsTable extends Table {
				PolarsTable(df, valueTypeProvider)
				-df: polars.DataFrame
				-valueTypeProvider: ValueTypeProvider
			}
		class TsTable extends Table {
				TsTable(numberOfRows, _columns)
				-numberOfRows: number
				-_columns: Map<string, TsTableColumn>
			}
		class PolarsTableColumn extends TableColumn {
				-series: polars.Series
			}
		class TsTableColumn<T extends InternalValueRepresentation> extends TableColumn {
			}
		TsTable "1" *-- "many" TsTableColumn
		PolarsTable "1" *-- "1" polars.DataFrame: df
		PolarsTableColumn "1" *-- "1" polars.Series: series
		@enduml
	\end{plantuml}
	\caption{How jayvee represents tables} % FIXME
	\label{fig:current_sit}
\end{figure}

\section{new executors}
- block executors are grouped in extensions.
- the jayvee interpreter calls createBlockExecutor() when looking for a block
- the extension returns a fitting result
\begin{figure}
	\begin{plantuml}
		@startuml
		abstract class JayveeExecExtension {
				{abstract} getBlockExecutors(): BlockExecutorClass[]
				getExecutorForBlockType(blockTypeName: string, usePolars: boolean, useRusqlite: boolean, logger: Logger): BlockExecutorClass | undefined
				createBlockExecutor(block: BlockDefinition, usePolars: boolean, useRusqlite: boolean, logger: Logger): BlockExecutor
			}
		class StdExecExtension extends JayveeExecExtension {
				getBlockExecutors(): BlockExecutorClass[]
			}
		class TabularExecExtension extends JayveeExecExtension {
				getBlockExecutors(): BlockExecutorClass[]
			}
		class RdbmsExecExtension extends JayveeExecExtension {
				getBlockExecutors(): BlockExecutorClass[]
			}
		@enduml
	\end{plantuml}
	\caption{} %TODO:
	\label{fig:uml:jayveeexecextension}
\end{figure}


\begin{figure}
	\begin{plantuml}
		@startuml
		abstract class JayveeExecExtension {
				{abstract} getBlockExecutors(): BlockExecutorClass[]
				getExecutorForBlockType(blockTypeName: string, usePolars: boolean, useRusqlite: boolean, logger: Logger): BlockExecutorClass | undefined
				createBlockExecutor(block: BlockDefinition, usePolars: boolean, useRusqlite: boolean, logger: Logger): BlockExecutor
			}

		class StdExecExtension extends JayveeExecExtension {
				getBlockExecutors(): BlockExecutorClass[]
			}
		class TabularExecExtension extends JayveeExecExtension {
				getBlockExecutors(): BlockExecutorClass[]
			}
		class RdbmsExecExtension extends JayveeExecExtension {
				getBlockExecutors(): BlockExecutorClass[]
			}
		annotation implementsStatic<T>
		interface BlockExecutorClass<T extends BlockExecutor> {
				<<readonly>> type: string
			}
		interface BlockExecutor<I extends IOType, O extends IOType> {
				<<readonly>> inputType: I
				<<readonly>> outputType: O
				execute(input: IOTypeImplementation<I\>, context): Result<IOTypeImplementation<O>>
			}
		abstract class AbstractBlockExecutor<I extends IOType, O extends IOType> implements BlockExecutor {
				AbstractBlockExecutor(inputType, outputType)
				-logBlockResult(result: IOTypeImplementation, context)
				{abstract} doExecute(input: IOTypeImplementation<I\>, context): Result<IOTypeImplementation<O>>
			}
		class TableTansfromerExecutor {}
		AbstractBlockExecutor <|-- TableTansfromerExecutor: AbstractBlockExecutor<IOType.TABLE, IOType.TABLE>
		implementsStatic - TableTansfromerExecutor: @implementsStatic<BlockExecutorClass>
		(TableTansfromerExecutor, implementsStatic) <|.. BlockExecutorClass: BlockExecutorClass<TableTansfromerExecutor>
		BlockExecutorClass .. JayveeExecExtension
		@enduml
	\end{plantuml}
	\caption{}
	\label{fig:}
\end{figure}

- block executors extend this abstract class:
\begin{figure}
	\begin{plantuml}
		@startuml
		interface BlockExecutor<I extends IOType, O extends IOType> {
				<<readonly>> inputType: I
				<<readonly>> outputType: O
				execute(input: IOTypeImplementation<I\>, context): Result<IOTypeImplementation<O>>
			}
		abstract class AbstractBlockExecutor<I extends IOType, O extends IOType> implements BlockExecutor {
				AbstractBlockExecutor(inputType, outputType)
				-logBlockResult(result: IOTypeImplementation, context)
				{abstract} doExecute(input: IOTypeImplementation<I\>, context): Result<IOTypeImplementation<O>>
			}
		@enduml
	\end{plantuml}
	\caption{} %TODO:
	\label{fig:uml:abstractblockexecutor}
\end{figure}

\subsection{TableInterpreter}
- same approach as always (strategy).
- move previous implementation into \Verb|TsTableInterpreter|
- create abstract class \Verb|TableInterpreter|
- create new class \Verb|PolarsTableInterpreter|
- \Verb|toPolarsDataTypeWithLogs| is its own mehtod to enable code sharing with other table blocks.
- can't be in language-server because circular dependency
- uses the already present \Verb|ColumnDefintionEntry|

\begin{figure}
	\begin{plantuml}
		@startuml
		abstract class TableInterpeter {
		doExecute(inputSheet: Sheet, context: R.ExecutionContext): Promise<R.Result<R.Table>>
		# {abstract} constructAndValidateTable(sheet: Sheet, header: boolean, columnEntries: ColumnDefinitionEntry[], context: ExecutionContext): Table
		# {static} deriveColumnDefinitionEntriesWithoutHeader(columnDefinitions: ValuetypeAssignment[], context: ExecutionContext): ColumnDefinitionEntry[]
		# {static} deriveColumnDefinitionEntriesFromHeader(columnDefinitions: ValuetypeAssignment[], headerRow: string[], context: ExecutionContext): ColumnDefinitionEntry[]
		# parseAndValidateValue(value: string, valueType: ValueType, context: ExecutionContext): InternalValueRepresentation | undefined
		}
		@enduml
	\end{plantuml}
	\caption{}
	\label{fig:uml:tableinterpreter}
\end{figure}

\subsubsection{PolarsTableInterpreter}
\begin{figure}
	\begin{plantuml}
		@startuml
		class PolarsTableInterpreterExecutor {
		+ {static} <<readonly>> type: 'PolarsTableInterpreter' = 'PolarsTableInterpreter';
		# constructAndValidateTable(sheet: Sheet, header: boolean, columnEntries: ColumnDefinitionEntry[], context: ExecutionContext): PolarsTable
		- constructSeries(rows: readonly (readonly string[])[], columnEntry: ColumnDefinitionEntry, context: ExecutionContext): pl.Series
		}
		@enduml
	\end{plantuml}
	\caption{}\label{fig:uml:polarstableinterpreter}
\end{figure}


\subsection{FileToTableIntepreter}
- combine TextFileInterpreter, CSVInterpreter, TableIntepreter.
- can recieve input from FileSelelector %TODO: check name
LocalFileExtrator, HTTPExtractor
\begin{figure}
	\begin{plantuml}
		@startuml
		hide empty members
		class FileToTableInterpreterExecutor {
		+ {static} <<readonly>> type : 'FileToTableInterpreter';
		FileToTableInterpreterExecutor()
		doExecute(file: BinaryFile, context: ExecutionContext): Result<Table>
		+ {static} colsAndSchema(context: ExecutionContext): { columnNames: string[]; schema: Record<string, PlDType>;}
		+ {static} csvOptions(context: ExecutionContext): Partial<ReadCsvOptions>
		+ {static} constructAndValidateTable(content: Buffer, options: Partial<ReadCsvOptions>, context: ExecutionContext): PolarsTable
		+ {static} deriveColumnDefinitionEntriesFromHeader(columnDefinitions: ValuetypeAssignment[], headerRow: string[], context: ExecutionContext): ColumnDefinitionEntry[]
		}
		abstract class AbstractBlockExecutor<I extends IOType, O extends IOType>
		AbstractBlockExecutor <|-- FileToTableInterpreterExecutor: AbstractBlockExecutor<IOType.FILE, IOType.Table>
		@enduml
	\end{plantuml}
	\caption{}\label{fig:uml:filetotableinterpreter}
\end{figure}

\subsection{LocalFileToTableIntepreter}
- combine LocalFileExtractor TextFileInterpreter, CSVInterpreter, TableIntepreter.
\begin{figure}
	\begin{plantuml}
		@startuml
		hide empty members
		class LocalFileToTableInterpreterExecutor {
		+ {static} <<readonly>> type : 'LocalFileToTableInterpreter';
		FileToTableInterpreterExecutor()
		doExecute(file: BinaryFile, context: ExecutionContext): Result<Table>
		+ constructAndValidateTable(content: None, options: Partial<ReadCsvOptions>, context: ExecutionContext): PolarsTable
		}
		abstract class AbstractBlockExecutor<I extends IOType, O extends IOType>
		AbstractBlockExecutor <|-- LocalFileToTableInterpreterExecutor: AbstractBlockExecutor<IOType.NONE, IOType.Table>
		@enduml
	\end{plantuml}
	\caption{}\label{fig:uml:localfiletotableinterpreter}
\end{figure}

\subsection{TableTransformer}
\subsubsection{abstract TableTransformer}
- again strategy.
\begin{figure}
	\begin{plantuml}
		@startuml
		hide empty members
		abstract class AbstractBlockExecutor<I extends IOType, O extends IOType>
		abstract class TableTransformerExecutor {
				TableTransformerExecutor()
				# logColumnOverwriteStatus(inputTable: Table, outputColumnName: string, context: ExecutionContext, transformOutputDetails: PortDetails)
				# checkInputColumnsExist(inputColumnNames: string[], inputTable: Table, context: ExecutionContext): Result<undefined>
			}
		AbstractBlockExecutor <|-- TableTransformerExecutor: AbstractBlockExecutor<IOType.TABLE, IOType.TABLE>
		@enduml
	\end{plantuml}
	\caption{}
	\label{fig:uml:tabletransformer}
\end{figure}
\subsubsection{PolarsTabletransformer}
\begin{figure}
	\begin{plantuml}
		@startuml
		class PolarsTableTransformerExecutor  {
		+ {static} <<readonly>> type : 'PolarsTableTransformer';
		- checkInputColumnsMatchTransformInputTypes(inputColumnNames: string[], inputTable: PolarsTable, transformInputDetailsList: PortDetails[], context: ExecutionContext): Result<Map<string, polars.Expr>>
		doExecute(inputTable: PolarsTable, context: ExecutionContext): Result<PolarsTable>
		}
		@enduml
	\end{plantuml}
	\caption{}
	\label{fig:uml:polarstabletransformer}
\end{figure}

\subsection{SQLiteLoader}
- again, create abstract class and move ts implementation into \Verb|TsSQLiteLoader|
\subsubsection{abstract SQLiteLoader}
- \Verb|SQLiteLoader<T>| has a general implementation for loading sqlite data utilising the abstract table methods methods.
\begin{figure}
	\begin{plantuml}
		@startuml
		hide empty members
		abstract class AbstractBlockExecutor<I extends IOType, O extends IOType>
		abstract class SQLiteLoaderExecutor<T extends Table> {
		SQLiteLoaderExecutor()
		doExecute(table: T, context: ExecutionContext): R.Result<None>
		# executeLoad(table: T, file: string, tableName: string, dropTable: boolean, context: ExecutionContext):Result<None>
		# {static} runQuery(db: sqlite3.Database, query: string): sqlite3.RunResult
		}
		AbstractBlockExecutor <|-- SQLiteLoaderExecutor: AbstractBlockExecutor<IOType.TABLE, IOType.NONE>
		@enduml
	\end{plantuml}
	\caption{}
	\label{fig:uml:sqliteloader}
\end{figure}

\subsubsection{PolarsSQLiteLoaderExecutor}
- doesn't override the blanket implementation provided by \Verb|SQLiteLoaderExecutor|.

\subsubsection{RustSQLiteLoaderExecutor}
- uses external library
- library offers one function \Verb|loadSQLite|. that can load an arrowIPC file into a sqlite database. (for why see implementation chapter)
- this function also has parameters to replicate the behavoiur of PolarsSQLiteExecutor (like droptable)


\begin{figure}
	\begin{plantuml}
		@startuml
		interface BlockExecutorClass<T extends BlockExecutor> {
				<<readonly>> type: string
			}
		class RustSQLiteLoaderExecutor implements BlockExecutorClass {
		+ {static} <<readonly>> type: 'RustSQLiteLoader'
		# executeLoad(table: PolarsTable, file: string, tableName: string, dropTable: boolean, context: ExecutionContext): Result<None>
		}
		class PolarsSQLiteLoaderExecutor implements BlockExecutorClass {
		+ {static} <<readonly>> type: 'PolarsSQLiteLoader'
		}
		class TsSQLiteLoaderExecutor implements BlockExecutorClass {
		+ {static} <<readonly>> type: 'TsSQLiteLoader'
		}
		abstract class SQLiteLoaderExecutor<T extends Table> {
		doExecute(table: T, context:ExecutionContext): Result<None>
		# {abstract} executeLoad(table: T, file: string, tableName: string, dropTable: boolean, context: ExecutionContext): Result<None>
		}
		SQLiteLoaderExecutor <|-- RustSQLiteLoaderExecutor: SQLiteLoader<PolarsTable>
		SQLiteLoaderExecutor <|-- PolarsSQLiteLoaderExecutor: SQLiteLoader<PolarsTable>
		SQLiteLoaderExecutor <|-- TsSQLiteLoaderExecutor: SQLiteLoader<TsTable>
		abstract class AbstractBlockExecutor<I extends IOType, O extends IOType> implements BlockExecutor {
		+ {abstract} doExecute(input: IOTypeImplementation<I\>, context: ExecutionContext): Result<IOTypeImplementation<O>\>
		}
		AbstractBlockExecutor <|-- SQLiteLoaderExecutor: AbstractBlockExecutor<IOType.TABLE, IOType.NONE>
		@enduml
	\end{plantuml}
	\caption{The Executors for SQLiteLoader}
	\label{fig:uml:sqliteloaderexecutor:combined}
\end{figure}


\section{transforms}
- instances of TransformExecutor are created by TableTransformer
- tstransforms returns the new columns directly, while polars returns an expression, that, if applied to a dataframe can create the new column

\section{expressions}
- there is no \Verb|ExpressionEvaluator| class, just a function \Verb|evaluateExpression|
- strategy pattern, the way we did it previously,is out.
- directly modifying the the values from the dataframe would require converting it back into a js datastructure, apply the expression, create new dataframe -> SLOW!
- utilise \Verb|polars.Expr|, which describe changes made to a polars DataFrame.
- add new method \Verb|polarsEvaluateExpression| that replicates the structure of \Verb|evaluateExpression|

\subsection{Operator Evaluators}
- unary, binary and ternary operations
- operator evaluator registry that can map an n-ness operator with its symbol to its evaluator
- used to calculate the cell value directly, based on the inputs. should leave that stuff to polars.
- polars offers expressions to create new series (columns). expressions can be chained
- evaluators will return polars expressions.
- this snippet \ref{lst:pl_expr_example} multiplies the values in column "a" with those in column "b".
\begin{listing}
	\begin{minted}{typescript}
use { pl } from 'nodejs-polars';
const dataFrame = ...;
const newDataFrame = dataFrame.withColumn(pl.col("a").mul(pl.col("b")))
	\end{minted}
	\caption{How to multiply column "a" and "b" of a dataframe}
	\label{lst:pl_expr_example}
\end{listing}
- instead of calculating the new values directly, evaluators now return pl.Expression
- adding a method to existing operators is simpler and clearer than having a paralell structure of PolarsOperatorEvaluator
- SOLUTION: have all operators implement an interface that extends the OperatorEvaluator interface and demands a polarsEvaluate method.
\begin{figure}
	\begin{plantuml}
		@startuml
		class AdditionOperatorEvaluator {
				AdditionOperatorEvaluator()
				doEvaluate(left: number, right: number): number
				polarsDoEvaluate(left: polars.Expr, right: polars.Expr): polars.Expr
			}

		class RoundOperatorEvaluator {
				RoundOperatorEvaluator()
				doEvaluate(operandValue: number): number
				polarsDoEvaluate(operand: polars.Expr): polars.Expr
			}
		DefaultUnaryOperatorEvaluator <|-- RoundOperatorEvaluator: DefaultUnaryOperatorEvaluator<number, number>

		abstract class DefaultBinaryOperatorEvaluator<L extends InternalValueRepresentation, R extends InternalValueRepresentation, T extends InternalValueRepresentation> {
		DefaultBinaryOperatorEvaluator(operator, leftValueTypeGuard, rightValueTypeGuard)
		+ <<readonly>> operator: BinaryExpressionOperator
		- <<readonly>> leftValueTypeGuard: InternalValueRepresentationTypeguard<L>
		- <<readonly>> rightValueTypeGuard: InternalValueRepresentationTypeguard<R>
		evaluate(expression: BinaryExpression, evaluationContext: EvaluationContext): T | undefined
		polarsEvaluate(expression: BinaryExpression, evaluationContext: EvaluationContext): polars.Expr | undefined
		# {abstract} doEvaluate(leftValue: L, rightValue: R, expression: BinaryExpression): T | undefined
		# polarsDoEvaluate(_left: polars.Expr, _right: polars.Expr, expression: BinaryExpression): polars.Expr | undefined
		}
		DefaultBinaryOperatorEvaluator <|-- AdditionOperatorEvaluator: DefaultBinaryOperatorEvaluator<number, number, number>

		abstract class DefaultUnaryOperatorEvaluator<O extends InternalValueRepresentation, T extends InternalValueRepresentation> {
		DefaultUnaryOperatorEvaluator(operator: string, operandValueTypeGuard: InternalValueRepresentationTypeguard<O>)
		+ <<readonly>> operator: BinaryExpressionOperator
		- <<readonly>> operandValueTypeGuard: InternalValueRepresentationTypeguard<O>
		evaluate(expression: UnaryExpression, evaluationContext: EvaluationContext): T | undefined
		polarsEvaluate(expression: UnaryExpression, evaluationContext: EvaluationContext): polars.Expr | undefined
		# {abstract} doEvaluate(operandValue: O, expression: UnaryExpression): T | undefined
		# polarsDoEvaluate(_operand: polars.Expr, expression: UnaryExpression): polars.Expr | undefined
		}

		interface PolarsOperatorEvaluator<E extends UnaryExpression | BinaryExpression | TernaryExpression> {
				<<readonly>> operator: E['operator']
				polarsEvaluate(expression: E, evaluationContext: EvaluationContext): polars.Expr | undefined
			}
		PolarsOperatorEvaluator <|.. DefaultBinaryOperatorEvaluator
		PolarsOperatorEvaluator <|.. DefaultUnaryOperatorEvaluator

		interface OperatorEvaluator<E extends UnaryExpression | BinaryExpression | TernaryExpression> {
				<<readonly>> operator: E['operator']
				evaluate(expression: E, evaluationContext: EvaluationContext): InternalValueRepresentation | undefined
			}
		OperatorEvaluator <|-- PolarsOperatorEvaluator

		interface OperatorEvaluatorRegistry {
				unary: Record<UnaryExpressionOperator,PolarsOperatorEvaluator<UnaryExpression>>
				binary: Record<BinaryExpressionOperator, PolarsOperatorEvaluator<BinaryExpression>>
			}

		class DefaultOperatorEvaluatorRegistry implements OperatorEvaluatorRegistry {
				DefaultOperatorEvaluatorRegistry(valueTypeProvider: ValueTypeProvider)
				- <<readonly>> valueTypeProvider: ValueTypeProvider
				unary: Record<UnaryExpressionOperator, UnaryOperatorTypeComputer>
				binary: Record<BinaryExpressionOperator, BinaryOperatorTypeComputer>
			}
		DefaultOperatorEvaluatorRegistry "1" -- "1" AdditionOperatorEvaluator: "'+'"
		DefaultOperatorEvaluatorRegistry "1" -- "1" RoundOperatorEvaluator: "'round'"
		@enduml
	\end{plantuml}
	\caption{Assuming the only operations were \Verb|round| and \Verb|plus|, this is how the Evaluators would be structured}
	\label{fig:evaluators_class_diagram}
\end{figure}



- type-computers that compute the output types of an operation. not touched.
- they can still verify that the user doesn't do illegal operations (like calling sqrt on text)
- they don't reflect the actual types used at runtime inside the dataframe.
