\chapter{Architecture}
\label{chapter:Architecture}

The objective of this thesis is to optimize Jayvee's internal data representation.
This necessitates modifying the Jayvee interpreter, the program, that parses Jayvee source files and executes the defined pipelines.

Prior to outlining that program's architecture, we will present an overview of the requirements for our modifications.

\section{Requirements}
\label{section:Requirements}

As a common practice we differentiate between functional and non functional requirements.
Both types of requirements have been evaluated for completenes, consistency and feasability by us.

\subsection{Functional Requirements}
\label{subsection:FunctionalRequirements}

\begin{enumerate}
	\item[FR-1] \textbf{interoperability} Provided by the standardized \emph{Apache Arrow}.
	\item[FR-2] \textbf{columnar} A columnar format has advantages outlined in \ref{section:column_vs_row}.
	      % \item[FR-3] \textbf{error free} Execute the electric vehicles example %TODO: link
	      %       without errors.
	      % \item{FR-4} \textbf{completeness}
	\item[FR-3]\label{fr:runtime} \textbf{feature toggle} We must be able to (de)activate the new features at runtime.
	      This makes comparing the new features easier. %FIXME fachausdruck
	\item[FR-4] \textbf{compatibility} Execute the electric vehicles example %TODO: link
	      without errors.
	      The resulting table must differ from the original result.
	\item[FR-5] \textbf{modularization} Should it be necessary to write code in a language other than typescript, this code must be placed in an external library usable from typesript.
\end{enumerate}

% Tables are the central way Jayvee represent's data.
% The other types like \Verb|TextFile| or \Verb|Sheet| mostly exists to be parsed into tables.
% Hence % TODO: ?
% we shall focus on how to efficiently represent tables in memory.
% Since Jayvee's \Verb|TableTransformer| work on columns and not rows, the advantages of the columnar format outlined in %TODO: ref
% lend themselves well to jayvee.
% Jayvee needs manipulate the data, so data needs to be stored in memory not on disk.
% 1. This leads to the requirement that \emph{tables are represented with a columnar, in-memory data layout}.
%
% The goal of this thesis is not to create a fully mature implementation of this new format, but rather to prototype an integration and evaluate the results of this migration.
% However to accurately evaluate the changes, the core functionality of jayvee (parse data into table, apply function to columns of that table, export table) needs to be preserved.
% 2. \emph{Core functionality is maintained}.
% This includes that tables can still be created in the same ways (\Verb|TableIntepreter|) and exported with the same blocks (\Verb|SQLiteLoader|) (\Verb|PostresLoader|).
% 3. \emph{Arithmetic operations work in transforms}.

% 4. Should it be necessary to write code in a language other than typescript, this code must be placed in an external library usable from typesript.
% This ensures usability and increases maintainability by for other developers.

% 5. To make evaluation easier the new implementation must be choosable with a commandline flag \emph{at runtime}.

\subsection{Non Functional Requirements}
\label{subsection:NonFunctionalRequirements}

\begin{enumerate}
	\item[NFR-1] \textbf{performance} The main goal of this thesis is to \emph{optimize} Jayvee's in-memory representation.
	      We expect this to result in either a decrease in the execution time for jayvee models, or an extension of the Jayvee interpreter's capabilities.
	\item[NFR-2] \textbf{readability} The source code is readable for non-rust developers
	\item[NFR-3] \textbf{consistent logging} The new code generates log messages consistent to the existing ones.
	\item[NFR-4] \textbf{codestyle} The source code adheres to the project's code style.
	      This is enforced by running \Verb|npm run lint|.
	      In rust code we use the defaults from rustfmt and clippy.
	\item[NFR-5] \textbf{maturity} We aim to create a prototype, not a mature implementation.
	\item[NFR-6] \textbf{extensibility} This prototype must extend the capabilities of polars / arrow %TODO rephrase
\end{enumerate}

\section{Interpreter Overview}
\label{section:prev}

% %TODO: architecture
% \begin{figure}
% 	\begin{plantuml}
% 		@startuml
% 		start
% 		:LocalFileExtractor;
% 		->File;
% 		:TextFileInterpreter;
% 		->TextFile;
% 		:CSVFileInterpreter;
% 		->Sheet;
% 		:TableInterpreter;
% 		->Table;
% 		:TableTransformer;
% 		->Table;
% 		:SQLiteLoader;
% 		stop
% 		@enduml
% 	\end{plantuml}
% 	\caption{The Flow of an examplory pipeline in jayvee. Between the blocks is noted the type of the data called IOType}
% 	\label{fig:}
% \end{figure}

This section will provide an overview of how the interpreter executes a Jayvee pipeline, illustrated by \ref{fig:uml:overview}.
How the interpreter parses a Jayvee source file is not relevant for the purpose of this thesis.

Once the parsing process is complete, the interpreter obtains a series of pipeline definitions, which consist of block definitions.
Block definitions include a \emph{blocktype}.
The interpreter uses this blocktype to find an executor for the block, which is a class that implements the \Verb|BlockExecutor| interface.
The interpreter then executes these executors in the order specified in the pipeline definition.
The output of the preceeding block executor is always the input for the subsequent one.

Inputs and outputs are instances of classes that implement the \Verb|IOTypeImplementation| interface.
This includes the \Verb|Table| class, which will be used to integrate Apache Arrow into the Jayvee interpreter.

One of Jayvee's core features is the transformation of tables with the \Verb|TableTransformer| blocktype.
Consequently, we will devote particular attention to this functionality.
The executor for \Verb|TableTransformerExecutor| is \Verb|TableTransformerExecutor|.
It creates and executes the \Verb|TransformExecutor|, which evaluates the transform's expression expression for every row of the table and returns the resulting column.
This column is then added to the input table by \Verb|TableTransformerExecutor|

Expressions are evaluated by the \Verb|evaluateExpression| function.
Expressions with parameter(s) (unary, binary, ternary) have evaluator classes that implement the \Verb|OperatorEvaluator| interface.
The \Verb|evaluateExpression| function finds the correct evaluator with the help of the \Verb|OperatorEvaluatorRegistry|.

\begin{figure}
	\begin{plantuml}
		@startuml
		hide members

		interface BlockExecutor
		interface BlockExecutorClass

		interface IOTypeImplementation
		BlockExecutor  -  IOTypeImplementation: input
		BlockExecutor - IOTypeImplementation: output
		class Table implements IOTypeImplementation

		abstract class AbstractBlockExecutor implements BlockExecutor
		class TableTransformerExecutor extends AbstractBlockExecutor implements BlockExecutorClass

		class TransformExecutor
		TableTransformerExecutor -- TransformExecutor: creates and executes >

		interface OperatorEvaluator
		abstract class DefaultBinaryOperatorEvaluator implements OperatorEvaluator
		abstract class DefaultUnaryOperatorEvaluator implements OperatorEvaluator
		class AdditionOperatorEvaluator extends DefaultBinaryOperatorEvaluator
		class RoundOperatorEvaluator extends DefaultUnaryOperatorEvaluator

		interface OperatorEvaluatorRegistry
		class DefaultOperatorEvaluatorRegistry implements OperatorEvaluatorRegistry
		TransformExecutor -- OperatorEvaluatorRegistry: looks up ""operator"" >
		OperatorEvaluatorRegistry - OperatorEvaluator: maps ""operator"" to an implementation of >
		@enduml
	\end{plantuml}
	\caption{The general structure of the Jayvee interpreter. Many subclasses and implementations have been omitted for readabiltiy.}
	\label{fig:uml:overview}
\end{figure}


% \begin{figure}
% 	\begin{plantuml}
% 		@startuml
% 		hide empty members
%
% 		interface PipelineDefinition
% 		interface BlockDefinition
%
% 		interface BlockExecutor<I extends IOType, O extends IOType> {
% 				+execute(input: IOTypeImplementation<I\>, context: ExecutionContext): Result<IOTypeImplementation<O>>
% 			}
%
% 		interface BlockExecutorClass {}
%
% 		PipelineDefinition "1" *-- "many" BlockDefinition
% 		BlockDefinition "1" --> "1" BlockExecutor: interpreter finds fitting implementation %FIXME: fitting
%
% 		interface IOTypeImplementation<T extends IOType>
% 		IOTypeImplementation - BlockExecutor: input
% 		IOTypeImplementation - BlockExecutor: output
%
% 		class Table
% 		IOTypeImplementation <|.. Table : IOTypeImplementation<IOType.TABLE>
%
% 		abstract class AbstractBlockExecutor<I extends IOType, O extends IOType> implements BlockExecutor {
% 		+ {abstract} doExecute(input: IOTypeImplementation<I\>, context: ExecutionContext): Result<IOTypeImplementation<O\>>
% 		}
%
% 		class TableTransformerExecutor {
% 				+doExecute(input: Table, context: ExecutionContext): Result<Table>
% 			}
% 		AbstractBlockExecutor <|-- TableTransformerExecutor: AbstractBlockExecutor<IOType.TABLE, IOType.TABLE>
% 		BlockExecutorClass <|-- TableTransformerExecutor
% 		@enduml
% 	\end{plantuml}
% 	\caption{How \Verb|Table| fits into the interpreter} %FIXME
% 	\label{fig:prev_sit}
% \end{figure}

\section{General Idea}
\label{section:General Idea}
We add an alternative table implemetation, based on the Apache Arrow framework \ref{section:arrow}, to the interpreter.
So the interpreter will contain two table implementations at the same time.
\textcite{Dooley2024} recommend the strategy pattern for this situation, because it will ensure that both implementations share a common interface and, that the different implementations can be chosen dynamically.

We also adapt the interpreter to take advantage of the new features introduced by the new table.
But, because the original implementation needs to be preserved here too, the strategy patters is a good approach again.

\begin{figure}
	\begin{plantuml}
		@startuml
		start
		:start interpreter;
		:parse model;
		if (parseOnly) then (yes)
		else (no)
		while (more pipeline)
		partition run pipelines {
				:sort blocks into execution order;
				while (more blocks)
				partition run block {
						partition get block exectutor {
								if (block has multiple executors) then (yes)
								if (usePolars) then (true)
								:pick polars executor;
								else (false)
								:pick typescript executor;
								endif
								else (no)
								:pick general executor;
								endif
							}
						:call exectutor;
						note
						<code>
						BlockExecutor<I extends IOType,O extends IOType>.execute(
						input: IOTypeImplementation<I>,
						context: ExectutionContext
						): Result<IOTypeImplementation<O>>
						</code>
						end note
						:save output as input for the next block;
					}
				endwhile
			}
		endwhile
		endif
		stop
		@enduml
	\end{plantuml}
	\caption{An activity diagram overview of the interpreter}
	\label{fig:interpreter_activity}
\end{figure}


\subsection{Possible implementations}
\label{subsection:arrow implementations}

In this section, we will discuss possible implementations of the arrow specification.

\subsubsection{Implementation from scratch}
\label{subsubsection:direct_implementation}
The most direct approach is a new implementation the Arrow specification.
This would have the advantage of having full control over the implementation.
However, it it not guaranteed that a sufficient ammount can be implemented within the timeframe of the thesis.
This implementation would likely perform worse than an existing, matured implementation, which is likely also be more correct.

An implementation from scratch is \emph{too big in scope} for a bachelor's thesis.

\subsubsection{Apache Arrow in TypeScript}
\label{subsubsection:arrow_in_js}
There is an Arrow library written in typescript \autocite{arrow:overview}, which is the lanugage of the Jayvee interpreter.
This implementation is comparable to those in other languages regarding supported datatypes, but is lags behind with support for other apache frameworks \autocite{arrow:status}, which takes away one of arrow's strengths.

\subsubsection{Polars}
\label{subsection:polars}
Polars is a high level api built on top of apache arrows, but it also offers useful abstractions like DataFrames, that hide the Arrow datatypes.
These abstractions make it easier for developers unfamiliar with Arrow to contribute to Jayvee.
Polars is written in rust, but offers a Java-/TypeScript \ac{API}, allowing us %FIXME: us
to access the speed of rust, %FIXME: citation + rewordig
while still remaining accessible to typescript developers.
For these reasons, we choose to build the new table implementaiton on top of polars.



\section{Type conversion}
\label{section:type_conversion}
Jayvee has a concept called ValueType, that represent Jayvee types, e.g. text, boolean or decimal.
They are useful because Jayvee types don't map directly to TypeScript types.
For example, when a value inside a table has the JavaScript type \Verb|number|, a ValueType is used to remember whether it's meant to be a Jayvee \Verb|integer| or Jayvee \Verb|decimal|.

Polars has the same system, except it's called DataType.
DataTypes are not compatible with ValueTypes, which leaves us with two possible approaches.
\begin{enumerate}
	\item \emph{Replace} ValueTypes with DataTypes.
	      We decided against this approach, because it forces the polars implementation at compile time, which breaks \ref{fr:runtime}.
	\item \emph{Convert} between ValueTypes and DataTypes when needed.
	      The TypesScript implementation can ignore this and keep using ValueTypes as before.
\end{enumerate}

For details on how this conversion mechanism is implemented, see \ref{subsection:TypeConversion}.

% Jayvee also defines a union type \Verb|InternalValueRepresentation| which aggregates %FIXME: aggregate
% all TypeScript types allowed in jayvee.
%
% This includes \Verb|string|, \Verb|number| and \Verb|boolean|.
%
% \subsection{Wrong Approach}
% At first we thought that polars' DataTypes were similar to \Verb|InternalValueRepresentation| and tried to add them to the union type.
% However pl.String does not contain an actual string it's just a symbol for the string type
%
% This happened because we did not understand the Difference between ValueTypes and InternalValueRepresentation


\section{Creating a Table implementation based on Polars}
\label{section:new_table}

The usual application of the strategy pattern would create an interface \autocite{Dooley2024} that both the old and the new table classes implement.
Instead, we utilise an abstract class, to allow for code-sharing between the table subclasses.
We can still define functionality for both subclasses using \emph{abstract methods}.

Jayvee already has a \Verb|Table| class that implements the \Verb|IOTypeImplementation<IOType.TABLE>| interface.
We move all of the functionality from \Verb{Table} to \Verb{TsTable} and create a new \emph{abstract} class \Verb|Table|.

\subsection{abstract Table}
This class implements the \Verb|IOTypeImplementation<IOType.TABLE>| interface to be allowed as an input / output for blocks.
It' methods are based on those of the original Table class.
See \ref{fig:uml:table} for a class diagram.

\subsubsection{Differences between the old Table and the new abstract Table}
\Verb|getRow|, \Verb|addRow|, \Verb|dropRow|, \Verb|dropRows| and \Verb|addColumn| are not part of the abstract table.
They still exist in the \Verb|TsTable| class to preserve original functionality.
The methods working with rows are not included, because they are not necessary for the Polars based implementation. %TODO: also because working with rows is slow, but I don't know if I need to cite that or not.
\Verb|addColumn| is replaced in favor of \Verb|withColumn|, the concrete differences are explained in \ref{subssubsection:impl:old_vs_new}.
Typeguards to distinguish the implementations, \Verb|isPolars| and \Verb|isTypescript|, were added.
Also, we replaced the \Verb|number_of_rows| proberty with getter method using the \Verb|get| keyword.

\begin{figure}
	\begin{plantuml}
		@startuml
		abstract class Table {
				{abstract} <<getter>> nRows(): number
					{abstract} <<getter>>  nColumns(): number
					{abstract} <<getter>> columns(): ReadonlyArray<TableColumn>
					{abstract} withColumn(column: TableColumn): Table
					{abstract} hasColumn(name: string): boolean
					{abstract} getColumn(name: string): TableColumn | undefined
					{abstract} clone(): Table
					{abstract} acceptVisitor<R>(visitor: IoTypeVisitor<R>): R
					{abstract} isPolars(): this is PolarsTable
					{abstract} isTypescript(): this is TsTable
					{static} generateDropTableStatement(tableName: string): string
					{abstract} generateInsertValuesStatement(tableName: string): string
					{abstract} generateCreateTableStatement(tableName: string): string
			}
		@enduml
	\end{plantuml}
	\caption{The class diagram of the \Verb{Table} class}
	\label{fig:uml:table}
\end{figure}

\subsection{PolarsTable}
\label{subsection:arch:polarstable}
Polars' \Verb|DataFrame| already has table functionality, like the ability to add/remove/transform columns.
However, \Verb|DataFrame|'s methods aren't the same as those required by \Verb|Table|.
To solve this, we create a wrapper class \Verb|PolarsTable|, that extends \Verb|Table| and thereby implements \Verb|IOTypeImplementation<IOType.TABLE>|, allowing \Verb|PolarsTable| to be used as an input / output for block executors.
\Verb|PolarsTable| extends \Verb|Table|'s abstract methods by calling \Verb|DataFrames| methods, which is a characteristic of the \emph{adapter pattern} \autocite{Dooley2024}.
In the terminology of the adapter pattern, \Verb|Table| is the target, \Verb|PolarsTable| the adapter and \Verb|DataFrame| the adaptee.

It is notable that when \Verb|Table| is parameter or return type in an abstract method in \Verb|Table|, the overriding method in \Verb|PolarsTable| replaced that with \Verb|PolarsTable|.
For example \mintedinline{typescript}{abstract clone(): Table} becomes \mintedinline{typescript}{override clone(): PolarsTable}.
This is legal %FIXME: maybe better term instead of legal
because \Verb|PolarsTable| is a subclass of \Verb|Table|.

In addition to the abstract methods from \Verb|Table|, \Verb|PolarsTable| also implements methods that take advantage of Polars' features not available to the TypeScript implementation.

\Verb|withColumnFormInternal| returns a new Table with the column resulting from the passed Polars expression added.
Polars expressions are a way to describe a series of operations, that result in one or more columns, with automatic optimization and parallelization \autocite{polars:docs:expr}.
\ref{lst:pl_expr_example} contains an example of how Polars expression can be chained.
\begin{listing}
	\begin{minted}{typescript}
use { pl } from 'nodejs-polars';
const dataFrame = ...; // Creation of the dataframe was omitted
// When the expression is applied, pl.col selects a column,
// based on name
const a = pl.col("a")
const b  = pl.col("b")
// When the expression is applied,
// mul multplies all values from expression a with
// those from b
const product = a.mul(b)
// alias gives the expression a new name
// When the expression is applied, this renames the column.
const renamed = product.alias("c");
// withColumn applies the expression and returns a DataFrame,
// containing the column computed by the expression.
const newDataFrame = dataFrame.withColumn(renamed)
// newDataFrame contains a column "c".
// "c" contains the values of column "a" multplied with the
// values from column "b"
	\end{minted}
	\caption{How to multiply the values in "a" and "b" of a DataFrame}
	\label{lst:pl_expr_example}
\end{listing}

\Verb|writeIpc| and \Verb|writeIpcTo| convert the table to the Arrow \ac{IPC} format, writing either into a Buffer or a File.

One of the negative consequences is that adding a column into the DataFrame is that the column's ValueType is lost, because the Dataframe uses polars' DataTypes.
This is problematic, because TableColumn expects a ValueType for it's constructor.
The solution is to convert the polars DataType of a column to a ValueType using the conversion mechanism in \ref{subsection:TypeConversion}.
Conversion requires a ValueTypeProvider, which is saved as one of PolarsTable's properties.

\Verb|PolarsTable| requires a \Verb|ValueTypeProvider|
to be passed to its contructor. See \ref{subsubsection:polarstablecolumn}.
See \ref{fig:uml:polarstable} for the class diagram.

\Ver
Now, we use Polars expressions, a way to describe a series of operations, that result in one or more columns, with automatic optimization and parallelization \autocite{polars:docs:expr}.
The approach to executing transforms no longer is to compute all the calues of the new column, but to create a Polars expression, and return it to \Verb|PolarsTableTransformerExecutor|.
As a consequence, we add the new function \Verb|jayveeExpressionToPolars|.
This function transfroms a Jayvee expression into a Polars Expression.
\Verb|PolarsTransformExecutor.executeTransform| returns this Polars expression to \Verb|PolarsTableTransformerExecutor|.
can apply the expression returned by \Verb|PolarsTransformExecutor.executeTransform| to its input table and compute the new column.


\begin{figure}
	\begin{plantuml}
		@startuml
		class PolarsTable {
				-df: polars.DataFrame
				-valueTypeProvider: ValueTypeProvider
				PolarsTable(df, valueTypeProvider)
				<<getter>> nRows(): number
				<<getter>> nColumns(): number
				<<getter>> columns(): readonly PolarsTableColumn[]
				getTypes(): ValueType[]
				generateInsertValuesStatement(tableName: string): string
				generateCreateTableStatement(tableName: string): string
				withColumn(column: PolarsTableColumn): PolarsTable
				withColumnFromInternal(expr: polars.Expr): PolarsTable
				hasColumn(name: string): boolean
				getColumn(name: string): PolarsTableColumn | undefined
				clone(): PolarsTable
				acceptVisitor<R>(visitor: IoTypeVisitor<R>): R
				isPolars(): this is PolarsTable
				isTypescript(): this is TsTable
				toString(): string
				writeIpc(options?: WriteIPCOptions): Buffer
				writeIpcTo(destination: string | Writable, options?: WriteIPCOptions): void
			}
		@enduml
	\end{plantuml}
	\caption{The class diagram of the \Verb{PolarsTable} class}
	\label{fig:uml:polarstable}
\end{figure}

\subsection{Implementing Columns}
Analogous to \Verb|Table| we create an abstract class \Verb|TableColumn| that has two subclasses, \Verb|TsTableColumn| and \Verb|PolarsTableColumn|

\subsubsection{\Verb{abstract TableColumn}}
Compared to the old \Verb|TableColumn| (\ref{fig:uml:old_tablecolumn}), the new abtract class no longer defines how the values of the column are saved.
It used to be a TypeScript array, but now this decision is left to the subclasses of \Verb|TableColumn|.
We utilise a generic type parameter, to remain close to the original implementation and to be more specific on the return type of \Verb|valueType()|.
The typeguards \Verb|isPolars()| and \Verb|isTypescript()| were added.

\begin{figure}
	\begin{plantuml}
		@startuml
		interface TableColumn<T extends InternalValueRepresentation>{
				+values: T[]
				+valueType: ValueType
			}
		@enduml
	\end{plantuml}
	\caption{The class diagram of the old \Verb|TableColumn|}
	\label{fig:uml:old_tablecolumn}
\end{figure}

\begin{figure}
	\begin{plantuml}
		@startuml
		abstract class TableColumn<T extends InternalValueRepresentation> {
				{abstract} <<getter>> valueType(): ValueType<T>
					{abstract} <<getter>> length(): number
					{abstract} <<getter>> name(): string
					{abstract} <<setter>> name(newName: string)
				{abstract} clone(): TableColumn<T>
					{abstract} isPolars(): this is PolarsTableColumn<T>
					{abstract} isTypescript(): this is TsTableColumn<T>
			}
		@enduml
	\end{plantuml}
	\caption{The \Verb|TableColumn| class diagram}
	\label{fig:uml:tablecolumn}
\end{figure}

\subsubsection{PolarsTableColumn}
\label{subsubsection:polarstablecolumn}
\Verb|DataFrame|'s \Verb|getColumn| method returns a \Verb|Series|, which means that \Verb|Series| represents a column in Polars.
To make \Verb|Series| useful, we create a class adapter with the target \Verb|TableColumn| and the adaptee \Verb|Series|.

One challenge here is that \Verb|Series| does not have a generic type parameter.
To overcome it, we can either create \Verb|PolarsTableColumn<T extends InternalValueRepresentation>|, extend \Verb|TableColumn<T>| and work around \Verb|Series|' limitations in the implementation, or, we create \Verb|PolarsTableColumn| without a type parameter too and extend the general \Verb|TableColumn<InternalValueRepresentation>|.
The former approach is preferable, because it allows us to preserve the generic type parameter of the \Verb|_valueType: ValueType<T>| property (see \ref{fig:uml:polarstablecolumn}).
To be clear, \Verb|T| does not denote actual the type of the values stored in the column, like it would for \Verb|Array<T>|.
This detail is left to \Verb|Series|.
\Verb|T| specifies what type the column's values would be if it were implemented in typescript, which is used to narrow down the type of \Verb|_valueType|.

\begin{figure}
	\begin{plantuml}
		@startuml
		class PolarsTableColumn<T extends InternalValueRepresentation> {
				-_valueType: ValueType<T>;
				-_series: polars.Series
				PolarsTableColumn(_series, _valueType)
				<<getter>> valueType(): ValueType<T>
				<<getter>> series(): Readonly<pl.Series>
				<<getter>> length(): number
				<<getter>> name(): string
				<<setter>> name(newName: string)
				clone(): PolarsTableColumn<T>
				isPolars(): this is PolarsTableColumn<T>
				isTypescript(): this is TsTableColumn<T>
			}
		@enduml
	\end{plantuml}
	\caption{The \Verb{PolarsTableColumn} class diagram}
	\label{fig:uml:polarstablecolumn}
\end{figure}

\subsubsection{TsTableColumn}
For \Verb|TsTableColumn|, the type parameter \Verb|T| behaves in the expected way, it denotes the type of the values saved in the column.
\Verb|TsTableColumn| can also be looked at through the lens of the adapter pattern.
Then, \Verb|TableColumn| is the target, \Verb|TsTableColumn| the adapter and \Verb|T[]| the adaptee.

In addition to the abstract methods from \Verb|TableColumn|, \Verb|TsTableColumn| also has methods that allow users? %FIXME
to use the wrapped array functionality, \Verb|push|, \Verb|at| and \Verb|drop|.
At one point during development, \Verb|at| was also implemented for \Verb|PolarsTableColum|, but it was unused and thus \Verb|at| was made exclusive to \Verb|TsTableColumn|.

\begin{figure}
	\begin{plantuml}
		@startuml
		class TsTableColumn<T extends InternalValueRepresentation> {
				- name: string
				-_valueType: ValueType<T>;
				-_values: T[]
				TsTableColumn(_name, _valueType, _values)
				<<getter>> valueType(): ValueType<T>
				<<getter>> length(): number
				<<getter>> name(): string
				<<setter>> name(newName: string)
				clone(): TsTableColumn<T>
				isPolars(): this is PolarsTableColumn<T>
				isTypescript(): this is TsTableColumn<T>
				push(value: T)
				at(index: number): T | undefined
				drop(index: number): T | undefined
			}
		@enduml
	\end{plantuml}
	\caption{The \Verb{PolarsTableColumn} class diagram}
	\label{fig:uml:tstablecolumn}
\end{figure}

\subsection{Overview over the new Table implementation}
\begin{figure}[h]
	\begin{plantuml}
		@startuml
		hide empty members
		interface IOTypeImplementation<T extends IOType = IOType> {
				+ioType: T
			}
		abstract class Table {
				+ioType: IOType.TABLE
			}
		IOTypeImplementation <|.. Table : IOtypeImplementation<IOType.TABLE>
		abstract class TableColumn<T> {
			}
		class PolarsTable extends Table {
				PolarsTable(df, valueTypeProvider)
				-df: polars.DataFrame
				-valueTypeProvider: ValueTypeProvider
			}
		class TsTable extends Table {
				TsTable(_columns, number_of_rows)
				-_columns: Map<string, TsTableColumn>
				-number_of_rows: number
			}
		class PolarsTableColumn<T> extends TableColumn {
				PolarsTableColumn(_series, _valueType)
				-_series: polars.Series
				-_valueType: ValueType<T>
			}
		class TsTableColumn<T> extends TableColumn {
				-_name: string
				-_valueType: ValueType<T>
				-_values: T[]
			}
		TsTable "1" *-- "many" TsTableColumn
		PolarsTable "1" *-- "1" polars.DataFrame: df
		PolarsTableColumn "1" *-- "1" polars.Series: series
		@enduml
	\end{plantuml}
	\caption{Overview of the classes relevant for the table implementation} % FIXME
	\label{fig:current_sit}
\end{figure}

\section{Adapting and creating Blocktypes}
The executors for Jayvee blocks are organized in extensions that extend the abstract class \Verb|JayveeExecExtension| (see \ref{fig:uml:jayveeexecextension}).
The Jayvee interpreter uses \Verb|createBlockExecutor| to get an implementation of the \Verb|BlockExecutor| interface.
This is the method that chooses the either the existing block executors or the new block executros that are described in this section.
For details on the implementation of this method, see \ref{subsection:createBlockExecutor}.

\begin{figure}
	\begin{plantuml}
		@startuml
		abstract class JayveeExecExtension {
				{abstract} getBlockExecutors(): BlockExecutorClass[]
				getExecutorForBlockType(blockTypeName: string, usePolars: boolean, useRusqlite: boolean, logger: Logger): BlockExecutorClass | undefined
				createBlockExecutor(block: BlockDefinition, usePolars: boolean, useRusqlite: boolean, logger: Logger): BlockExecutor
			}
		class StdExecExtension extends JayveeExecExtension {
				getBlockExecutors(): BlockExecutorClass[]
			}
		class TabularExecExtension extends JayveeExecExtension {
				getBlockExecutors(): BlockExecutorClass[]
			}
		class RdbmsExecExtension extends JayveeExecExtension {
				getBlockExecutors(): BlockExecutorClass[]
			}
		@enduml
	\end{plantuml}
	\caption{The Jayvee Execution Extensions} %TODO:
	\label{fig:uml:jayveeexecextension}
\end{figure}

% \begin{figure}
% 	\begin{plantuml}
% 		@startuml
% 		abstract class JayveeExecExtension {
% 				{abstract} getBlockExecutors(): BlockExecutorClass[]
% 				getExecutorForBlockType(blockTypeName: string, usePolars: boolean, useRusqlite: boolean, logger: Logger): BlockExecutorClass | undefined
% 				createBlockExecutor(block: BlockDefinition, usePolars: boolean, useRusqlite: boolean, logger: Logger): BlockExecutor
% 			}
%
% 		class StdExecExtension extends JayveeExecExtension {
% 				getBlockExecutors(): BlockExecutorClass[]
% 			}
% 		class TabularExecExtension extends JayveeExecExtension {
% 				getBlockExecutors(): BlockExecutorClass[]
% 			}
% 		class RdbmsExecExtension extends JayveeExecExtension {
% 				getBlockExecutors(): BlockExecutorClass[]
% 			}
% 		annotation implementsStatic<T>
% 		interface BlockExecutorClass<T extends BlockExecutor> {
% 				<<readonly>> type: string
% 			}
% 		interface BlockExecutor<I extends IOType, O extends IOType> {
% 				<<readonly>> inputType: I
% 				<<readonly>> outputType: O
% 				execute(input: IOTypeImplementation<I\>, context): Result<IOTypeImplementation<O>>
% 			}
% 		abstract class AbstractBlockExecutor<I extends IOType, O extends IOType> implements BlockExecutor {
% 				AbstractBlockExecutor(inputType, outputType)
% 				-logBlockResult(result: IOTypeImplementation, context)
% 				{abstract} doExecute(input: IOTypeImplementation<I\>, context): Result<IOTypeImplementation<O>>
% 			}
% 		class TableTansfromerExecutor {}
% 		AbstractBlockExecutor <|-- TableTansfromerExecutor: AbstractBlockExecutor<IOType.TABLE, IOType.TABLE>
% 		implementsStatic - TableTansfromerExecutor: @implementsStatic<BlockExecutorClass>
% 		(TableTansfromerExecutor, implementsStatic) <|.. BlockExecutorClass: BlockExecutorClass<TableTansfromerExecutor>
% 		BlockExecutorClass .. JayveeExecExtension
% 		@enduml
% 	\end{plantuml}
% 	\caption{}
% 	\label{fig:}
% \end{figure}

The only class implementing \Verb|BlockExecutor| is the abstract class \Verb|AbstractBlockExecutor|.
It exists as an intermediary between \Verb|BlockExecutor| and the concrete classes implementing it.
Classes extending \Verb|AbstractBlockExecutor|, instead of implementing \Verb|BlockExecutor|, benefit from its general implementation of \Verb|execute|, that leaves the execution behaviour to \Verb|doExecute|.
See \ref{fig:uml:abstractblockexecutor}

\begin{figure}
	\begin{plantuml}
		@startuml
		interface BlockExecutor<I extends IOType, O extends IOType> {
				<<readonly>> inputType: I
				<<readonly>> outputType: O
				execute(input: IOTypeImplementation<I\>, context): Result<IOTypeImplementation<O>\>
			}
		abstract class AbstractBlockExecutor<I extends IOType, O extends IOType> implements BlockExecutor {
				AbstractBlockExecutor(inputType, outputType)
				-logBlockResult(result: IOTypeImplementation, context)
				{abstract} doExecute(input: IOTypeImplementation<I\>, context): Result<IOTypeImplementation<O>\>
			}
		@enduml
	\end{plantuml}
	\caption{\Verb|AbstractBlockExecuotor|'s  class diagram.}
	\label{fig:uml:abstractblockexecutor}
\end{figure}

\subsection{TableInterpreter}
The \Verb|TableInterpreter| blocktype converts a Sheet, Jayvee's representation for \ac{CSV} data, into a Table.
We create an abstract class \Verb|TableInterpreterExecutor| that extends \Verb|AbstractTableInterpreter<IOType.SHEET, IOType.Table>| (\ref{fig:uml:tableinterpreter}).
For implementation details, see \ref{section:tableinterpreterexecutor}.
\Verb|TableInterpreter| has two subclasses, \Verb|TsTableInterpreter|, which contains the old behaviour, and the new \Verb|PolarsTableInterpreter|.

This architecture, like the table implementation, follows the strategy pattern from \autocite{Dooley2024}.
The usual singular strategy interface is split up into \Verb|BlockExecutor|, \Verb|AbstractBlockExecutor| and \Verb|TableInterpreterExecutor|, while the concrete strategy is either \Verb|TsTableInterpreterExecutor| or \Verb|PolarsTableInterpreterExecutor|.

We use static methods to implement behaviour that is useful for other executors as well.

\begin{figure}
	\begin{plantuml}
		@startuml
		hide empty members
		abstract class TableInterpreter {
		doExecute(inputSheet: Sheet, context: R.ExecutionContext): Promise<R.Result<R.Table>\>
		# {abstract} constructAndValidateTable(sheet: Sheet, header: boolean, columnEntries: ColumnDefinitionEntry[], context: ExecutionContext): Table
		# {static} deriveColumnDefinitionEntriesWithoutHeader(columnDefinitions: ValuetypeAssignment[], context: ExecutionContext): ColumnDefinitionEntry[]
		# {static} deriveColumnDefinitionEntriesFromHeader(columnDefinitions: ValuetypeAssignment[], headerRow: string[], context: ExecutionContext): ColumnDefinitionEntry[]
		# parseAndValidateValue(value: string, valueType: ValueType, context: ExecutionContext): InternalValueRepresentation | undefined
		}

		abstract class AbstractBlockExecutor<I extends IOType, O extends IOType>
		AbstractBlockExecutor <|-- TableInterpreter: AbstractBlockExecutor<IOType.SHEET, IOType.TABLE>

		class PolarsTableInterpreterExecutor extends TableInterpreter {
		+ {static} <<readonly>> type: 'PolarsTableInterpreter' = 'PolarsTableInterpreter';
		# constructAndValidateTable(sheet: Sheet, header: boolean, columnEntries: ColumnDefinitionEntry[], context: ExecutionContext): PolarsTable
		- constructSeries(rows: readonly (readonly string[])[], columnEntry: ColumnDefinitionEntry, context: ExecutionContext): pl.Series
		}
		@enduml
	\end{plantuml}
	\caption{Class diagram of the \Verb|TableInterpreterExecutor|}
	\label{fig:uml:tableinterpreter}
\end{figure}


\subsection{FileToTableIntepreter}
\label{subsection:FileToTableInterpreter}
This block recieves a \Verb|BinaryFile|, which contains a JavaScript \Verb|ArrayBuffer| and converts that into a Table, combining TextFileInterpreter, CSVInterpreter and TableInterpreter.
Unifiying these blocks allows us to utilize Polars' builtin \ac{CSV} parsing functionality, instead of relying on the \Verb|fast-csv| library like \Verb|CSVInterpreter|.
This means less indirection when reading a \ac{CSV} file.
This block can recieve \Verb|BinaryFile| from multiple blocktypes, including \Verb|LocalFileExtractor| and \Verb|HTTPExtractor|.

To add this blocktype to the Jayvee language, it's definition is put in \Verb|libs/language-server/src/stdlib/builtin-block-types/FileToTableInterpreter.jv|.
Running the command \Verb|npm run generate| creates the necessary files for this blocktype to be used in the Jayvee interpreter \autocite{jvalue:jayvee:docs:stdlib}.

We also create an executor for the new blocktype (\ref {fig:uml:filetotableinterpreter}).
All methods except \Verb|doExecute| are static, making them reusable by other executors. In practice, the only executor using these is \Verb|LocalFileToTableExtractorExecutor|.
Because there is no preexisting implementation of this executor, we do not need an additional abstract class and can extend \Verb|AbstractBlockExecutor| directly.

\begin{figure}
	\begin{plantuml}
		@startuml
		hide empty members
		class FileToTableInterpreterExecutor {
		+ {static} <<readonly>> type : 'FileToTableInterpreter';
		FileToTableInterpreterExecutor()
		doExecute(file: BinaryFile, context: ExecutionContext): Result<Table>
		+ {static} colsAndSchema(context: ExecutionContext): { columnNames: string[]; schema: Record<string, PlDType>;}
		+ {static} csvOptions(context: ExecutionContext): Partial<ReadCsvOptions>
		+ {static} deriveColumnDefinitionEntriesFromHeader(columnDefinitions: ValuetypeAssignment[], headerRow: string[], context: ExecutionContext): ColumnDefinitionEntry[]
		}
		abstract class AbstractBlockExecutor<I extends IOType, O extends IOType>
		AbstractBlockExecutor <|-- FileToTableInterpreterExecutor: AbstractBlockExecutor<IOType.FILE, IOType.Table>
		@enduml
	\end{plantuml}
	\caption{The class diagram for \Verb{FileToTableInterpreter}}
	\label{fig:uml:filetotableinterpreter}
\end{figure}

\subsection{LocalFileToTableExtractor}
The \Verb|LocalFileToTableExtractor| blocktype combines \Verb|LocalFileExtractor| and \Verb|FileToTableInterpreter|.
This removes another layer of indirection for parsing csv data, letting polars handle as much of the process as possible.

The process of adding the blocktype to jayvee is the same as described in \ref{subsection:FileToTableInterpreter},
the only difference being that the definition file is placed in \Verb|libs/language-server/src/stdlib/builtin-block-types/LocalFileToTableInterpreterExecutor.jv|.
\ref{fig:uml:localfiletotableinterpreter} contains the executor's class diagram.

\begin{figure}
	\begin{plantuml}
		@startuml
		hide empty members
		class LocalFileToTableExtractorExecutor {
		+ {static} <<readonly>> type : 'LocalFileToTableExtractor';
		FileToTableInterpreterExecutor()
		doExecute(file: BinaryFile, context: ExecutionContext): Result<Table>
		}
		abstract class AbstractBlockExecutor<I extends IOType, O extends IOType>
		AbstractBlockExecutor <|-- LocalFileToTableInterpreterExecutor: AbstractBlockExecutor<IOType.NONE, IOType.Table>
		@enduml
	\end{plantuml}
	\caption{Class diagram for \Verb{LocalFileToTableInterpreterExtractor}}
	\label{fig:uml:localfiletotableinterpreter}
\end{figure}

\begin{figure}
	\begin{subfigure}[h]{0.3\linewidth}
		\begin{plantuml}
			@startuml
			start
			-> None;
			:LocalFileExtractor;
			-> File;
			:TextFileInterpreter;
			-> TextFile;
			:CSVFileInterpreter;
			-> Sheet;
			:TableInterpreter;
			-> Table;
			stop
			@enduml
		\end{plantuml}
		\caption{only original blocks}
	\end{subfigure}
	\hfill
	\begin{subfigure}[h]{0.3\linewidth}
		\begin{plantuml}
			@startuml
			start
			-> None;
			:LocalFileExtractor;
			-> File;
			:FileToTableInterpreter;
			-> Table;
			stop
			@enduml
		\end{plantuml}
		\caption{\Verb{FileToTableInterpreter}}
	\end{subfigure}
	\hfill
	\begin{subfigure}[h]{0.3\linewidth}
		\begin{plantuml}
			@startuml
			start
			-> None;
			:LocalFileInterpreter;
			-> Table;
			stop
			@enduml
		\end{plantuml}
		\caption{\Verb{LocalFileToTableInterpreter}}
	\end{subfigure}
	\caption{Jayvee Pipelines using ...}
\end{figure}

\subsection{TableTransformer}
% Blocks with type \Verb|TableTransformer| are Jayvee's main method of manipulating data.
% This subsection is only concerned with the executor of this blocktype, the architecture of transforms is explained in \ref{section:transforms}, expressions in \ref{section:expressions}.

We still follow the strategy pattern, so, we create another abstract class \Verb|TableTransformer| (\ref{fig:uml:tabletransformer}) with two subclasses \Verb|TsTableTransformer| and \Verb|PolarsTableTransformer| (\ref{fig:uml:polarstabletransformer}).
As usual the created abstract class contains some shared behaviour, in this case \Verb|logColumnOverwriteStatus| and \Verb|checkInputColumnsExist|.

Blocks with type \Verb|TableInterpreter| use Jayvee transforms to compute an ouptput column from a series of input columns.
Jayvee transforms are executed by \Verb|TransformExecutor|s (see \ref{section:transforms}).

\begin{figure}
	\begin{plantuml}
		@startuml
		hide empty members
		abstract class AbstractBlockExecutor<I extends IOType, O extends IOType>
		abstract class TableTransformerExecutor {
				TableTransformerExecutor()
				# logColumnOverwriteStatus(inputTable: Table, outputColumnName: string, context: ExecutionContext, transformOutputDetails: PortDetails)
				# checkInputColumnsExist(inputColumnNames: string[], inputTable: Table, context: ExecutionContext): Result<undefined>
			}
		AbstractBlockExecutor <|-- TableTransformerExecutor: AbstractBlockExecutor<IOType.TABLE, IOType.TABLE>
		@enduml
	\end{plantuml}
	\caption{}
	\label{fig:uml:tabletransformer}
\end{figure}
\begin{figure}
	\begin{plantuml}
		@startuml
		class PolarsTableTransformerExecutor  {
		+ {static} <<readonly>> type : 'PolarsTableTransformer';
		- checkInputColumnsMatchTransformInputTypes(inputColumnNames: string[], inputTable: PolarsTable, transformInputDetailsList: PortDetails[]): Result<Map<string, polars.Expr>>
		doExecute(inputTable: PolarsTable, context: ExecutionContext): Result<PolarsTable>
		}
		@enduml
	\end{plantuml}
	\caption{}
	\label{fig:uml:polarstabletransformer}
\end{figure}

\subsection{SQLiteLoaderExecutor}
Jayvee blocks with type SQLiteLoader load their input table into a SQLite database.
Its output IOType is \Verb|None|, so no blocks in the pipeline can come after a block with type SQLiteLoader.
The abstract \Verb|SQLiteLoaderExecutor| (\ref{fig:uml:sqliteloader}) offers a general implementation, utilising methods defined in the abstract \Verb|Table| class.
This approach includes serializing all of the data contained in the input table into a \ac{SQL} query with type string.
We consider this to be a non-optimal representation of the data and improve it in \ref{arch:sqlite:rust}.

\Verb|SQLiteLoaderExecutor| has three subclasses:
\Verb|TsSQLiteLoaderExecutor| doesn't override the superclass' methods to preserve the original TypeScript implementation.
\Verb|PolarSQLiteLoaderExecutor| doesn't override the superclass' methods, because Polars' nodejs \ac{API} does not offer any database functionality at the time of writing. %FIXME make sure you can write `at the time of writing`.
The different behaviour results from different overrides of the \Verb|generateCreateTableStatement| and \Verb|generateInsertValuesStatement| in the \Verb|PolarsTable| and \Verb|TsTable| classes.

\begin{figure}
	\begin{plantuml}
		@startuml
		hide empty members
		abstract class AbstractBlockExecutor<I extends IOType, O extends IOType>
		abstract class SQLiteLoaderExecutor<T extends Table> {
		SQLiteLoaderExecutor()
		doExecute(table: T, context: ExecutionContext): R.Result<None>
		# executeLoad(table: T, file: string, tableName: string, dropTable: boolean, context: ExecutionContext):Result<None>
		# {static} runQuery(db: sqlite3.Database, query: string): sqlite3.RunResult
		}
		AbstractBlockExecutor <|-- SQLiteLoaderExecutor: AbstractBlockExecutor<IOType.TABLE, IOType.NONE>
		@enduml
	\end{plantuml}
	\caption{\Verb{SQLiteLoaderExecutor} class diagram}
	\label{fig:uml:sqliteloader}
\end{figure}

\subsubsection{RustSQLiteLoaderExecutor}
\label{arch:sqlite:rust}
\Verb|RustSQLiteLoaderExecutor| avoids serializing the input table's data into a \ac{SQL} query string, by relying on an external library, \Verb|sqlite-loader-lib|.
using generating \ac{SQL} statements.

\subsubsection{sqlite-loader-lib}
Polars' core functionality is written in Rust, which \textcite{polars} describe as allowing "for high performance with fine grained control over memory".
For this reason, we choose Rust to implement sqlite-loader-lib.

Polars uses NAPI-RS \autocite{polars:src:napi}, which compiles a Rust library to a nodejs addon \autocite{napi}.
WIth this, the Jayvee interpeter, written in TypeScript, can use functions from a library written in Rust.

The \Verb|RustSQLiteLoaderExecutor|'s role is to save its input table into an Arrow \ac{IPC} file on disk, because passing the \Verb|PolarsTable| object to sqlite-loader-lib through a function parameter is %FIXME decide if it is too complex or if it seems too complex, orif it just isnt supported
too complex for NAPI-RS.

Because the library only exists to execute a single task, it only exposes one function \mint{typescript}{loadSqlite(ipcPath: string, tableName: string, sqlitePath: string, dropTable: boolean): void}.
Its parameters are the path of the Arrow \ac{IPC} file and the properties of the \Verb|SQLiteLoader| block.

Polars' Rust implementation doesn't offer database export either. %TODO At the time of writing
As a consequence, \Verb|sqlite-loader-lib| uses a seperate library to to interface with an sqlite database.
This library, known as Connector Arrow, enables the writing of Arrow record batches into a SQLite database table \autocite{connector-arrow}.
Connector Arrow relies on the rusqlite library to support SQLite databases \autocite{connector-arrow}.

See \ref{subsection:sqlite-loader-lib} for the implementation.


\ref{fig:uml:sqliteloaderexecutor:combined} contains diagram of all classes connected to loading the table into SQLite.

\begin{figure}
	\begin{plantuml}
		@startuml
		interface BlockExecutorClass<T extends BlockExecutor> {
				<<readonly>> type: string
			}
		class RustSQLiteLoaderExecutor implements BlockExecutorClass {
		+ {static} <<readonly>> type: 'RustSQLiteLoader'
		# executeLoad(table: PolarsTable, file: string, tableName: string, dropTable: boolean, context: ExecutionContext): Result<None>
		}
		class PolarsSQLiteLoaderExecutor implements BlockExecutorClass {
		+ {static} <<readonly>> type: 'PolarsSQLiteLoader'
		}
		class TsSQLiteLoaderExecutor implements BlockExecutorClass {
		+ {static} <<readonly>> type: 'TsSQLiteLoader'
		}
		abstract class SQLiteLoaderExecutor<T extends Table> {
		doExecute(table: T, context:ExecutionContext): Result<None>
		# {abstract} executeLoad(table: T, file: string, tableName: string, dropTable: boolean, context: ExecutionContext): Result<None>
		}
		SQLiteLoaderExecutor <|-- RustSQLiteLoaderExecutor: SQLiteLoader<PolarsTable>
		SQLiteLoaderExecutor <|-- PolarsSQLiteLoaderExecutor: SQLiteLoader<PolarsTable>
		SQLiteLoaderExecutor <|-- TsSQLiteLoaderExecutor: SQLiteLoader<TsTable>
		abstract class AbstractBlockExecutor<I extends IOType, O extends IOType> implements BlockExecutor {
		+ {abstract} doExecute(input: IOTypeImplementation<I\>, context: ExecutionContext): Result<IOTypeImplementation<O>\>
		}
		AbstractBlockExecutor <|-- SQLiteLoaderExecutor: AbstractBlockExecutor<IOType.TABLE, IOType.NONE>
		@enduml
	\end{plantuml}
	\caption{The Executors for SQLiteLoader}
	\label{fig:uml:sqliteloaderexecutor:combined}
\end{figure}


\section{Transforms}
\label{section:transforms}
The \Verb|TableTransfromerExecutor| class creates an instance of a concrete subclass of \Verb|TransformExecutor| to compute a new column for it's input table.
For \Verb|PolarsTableTransformerExecutor| this is an instance of  \Verb|PolarsTransformExecutor| (\ref{fig:uml:transformexecutor}), for \Verb|TsTableTransformerExecutor| this is \Verb|TsTransformExecutor|.
% Then, that instance's \Verb|executeTransform| method is called, which returns either the new column or an expression to compute the new column.

Originally, \Verb|TransformExecutor| would compute the new column by following the algorithm outlined in \ref{lst:old_eval}.
\begin{listing}
	\begin{minted}{python}
newColumn = ...  # An empty column
expression = transform.expression
for row in inputColumns:
	...  # add row to evaluation context
	let value = evaluateExpression(expression, context)
	newColumn.add(newColumn)
	...  # remove row from evaluation context
return newColumn
	\end{minted}
	\caption{Pseudocode of the algorithm the interpreter used to execute transforms}
	\label{lst:old_eval}
\end{listing}
It applies the jayvee expression to each row in the input columns and returns a column.
The new approach transforms the Jayvee expression into a Polars expression, that the \Verb|PolarsTableTransformer| can apply to its input table.
So, we add the new function\Verb|jayveeExpressionToPolars| (see \ref{section:expressions}), which is similar to the existing \Verb|evaluateExpression|, but it returns a Polars expression, not a final value.

A detailed explanation of this process can be found at \ref{section:impl:transforms}.

\begin{figure}
	\begin{plantuml}
		@startuml
		hide empty members
		abstract class TransformExecutor<I, O> {
		- <<readonly>> transform: TransformDefinition
		- <<readonly>> context: ExecutionContext
		TransformExecutor(transform, context)
		getInputDetails(): PortDetails[]
		getOutputDetails(): PortDetails
		# getPortDetails(kind: TransformPortDefinition['kind']): { port: TransformPortDefinition; valueType: ValueType;}[]
		getOutputAssignment(): TransformOutputAssignment
		executeTransform(input: I, context: ExecutionContext): O | undefined
		# {abstract} doExecuteTransform(input: I, context: ExecutionContext): O | undefined;
		}
		class PolarsTransformExecutor  {
		- {static} addInputColumnsToContext(inputDetailsList: readonly PortDetails[], variableToColumnName: ReadonlyMap<string, pl.Expr>, evaluationContext: EvaluationContext)
		# doExecuteTransform(variableToColumnName: Map<string, pl.Expr>, context: ExecutionContext): pl.Expr | undefined
		}
		TransformExecutor <|-- PolarsTransformExecutor: TransformExecutor<Map<string, PolarsInternal>, PolarsInternal>
		@enduml
	\end{plantuml}
	\caption{\Verb|PolarsTransformExecutor| class diagram.}
	\label{fig:uml:transformexecutor}
\end{figure}

\section{Expressions}
\label{section:expressions}
\textcite{polars:docs:expr} seperate Jayvee expressions into three categories: \emph{literals}, \emph{variables}, \emph{operators}.
\begin{description}
	\item[literal] Concrete values, e.g. \Verb|5|, \Verb|"sometext"| or \Verb|true|.
	      Their evaluation does not differ from the original implementation.
	\item[variable] Represents a value defined in the evaluation context (\ref{fig:uml:eval_context}).
	      Variables are used to refer to columns inside of transfroms.
	\item[operator] Transforms one to three Jayvee expressions into one result.
	      The evaluation context contains a registry of operator evaluators (see \ref{subsection:arch:operator_evaluators})
\end{description}
Jayvee expressions are transformed to Polars expressions using the function \Verb|jayveeExpressionToPolars| (see \ref{impl:expressions}).

\begin{figure}
	\begin{plantuml}
		@startuml
		class EvaluationContext {
				- <<readonly>> variableValues: Map<string, InternalValueRepresentation | pl.Expr>
				- valueKeywordValue: InternalValueRepresentation | undefined;

				+ <<readonly>> runtimeParameterProvider: RuntimeParameterProvider;
				+ <<readonly>> operatorRegistry: OperatorEvaluatorRegistry;
				+ <<readonly>> valueTypeProvider: valueTypeProvider;

				getValueFor(literal: FreeVariableLiteral): InternalValueRepresentation | pl.Expr | undefined
				setValueForReference(refText: string, value: InternalValueRepresentation | pl.Expr): void
				deleteValueForReference(refText: string): void
				getValueForReference(referenceLiteral: ReferenceLiteral): InternalValueRepresentation | pl.Expr | undefined

				hasValueForRuntimeParameter(key: string): boolean
				getValueForRuntimeParameter<I extends InternalValueRepresentation>(key: string, valueType: ValueType<I\>): I | undefined

				setValueForValueKeyword(value: InternalValueRepresentation)
				deleteValueForValueKeyword()
				getValueForValueKeyword(literal: ValueKeywordLiteral, valueTypeProvider: ValueTypeProvider): InternalValueRepresentation | undefined
			}
		@enduml
	\end{plantuml}
	\caption{\Verb{EvaluationContext} class diagram}.
	\label{fig:uml:eval_context}
\end{figure}

\subsection{Operator evaluators}
\label{subsection:arch:operator_evaluators}
Evaluators implement the \Verb|OperatorEvaluator| interface.

We create a new interface \Verb|PolarsOperatorEvaluator|, that defines one method, \Verb|polarsEvaluate| and extends the existing \Verb|OperatorEvaluator|.
As a consequence, all classes that implement \Verb|PolarsOperatorEvaluator| are also required to implements the properties defined by \Verb|OperatorEvaluator|.
This guarantees that the existing typescript implemntation remains avaliable.

All classes, that previously implemented \Verb|OperatorEvaluator| interface, now implement \Verb|PolarsOperatorEvaluator| (see \ref{subsubsection:impl:operator_evaluator}).

We deliberately did not follow the strategy pattern approach here.
Jayvee currently has ~32 evaluator operators. %FIXME: decide whether to be imprecise or not. I counted 32
The strategy pattern requires two additional classes per evaluator, one for the abstract class and one for the polars implementation.
This would increase the number of evaluator classes to 96.
We considered implementing one additional method the simpler option.

\ref{fig:uml:evaluators} visualizes the inheritance structure for operator evaluators.

\begin{figure}
	\begin{plantuml}
		@startuml
		hide members
		class AdditionOperatorEvaluator {
				AdditionOperatorEvaluator()
				doEvaluate(left: number, right: number): number
				polarsDoEvaluate(left: polars.Expr, right: polars.Expr): polars.Expr
			}

		class RoundOperatorEvaluator {
				RoundOperatorEvaluator()
				doEvaluate(operandValue: number): number
				polarsDoEvaluate(operand: polars.Expr): polars.Expr
			}
		DefaultUnaryOperatorEvaluator <|-- RoundOperatorEvaluator: DefaultUnaryOperatorEvaluator<number, number>

		abstract class DefaultBinaryOperatorEvaluator<L, R, T> {
		DefaultBinaryOperatorEvaluator(operator, leftValueTypeGuard, rightValueTypeGuard)
		+ <<readonly>> operator: BinaryExpressionOperator
		- <<readonly>> leftValueTypeGuard: InternalValueRepresentationTypeguard<L>
		- <<readonly>> rightValueTypeGuard: InternalValueRepresentationTypeguard<R>
		evaluate(expression: BinaryExpression, evaluationContext: EvaluationContext): T | undefined
		polarsEvaluate(expression: BinaryExpression, evaluationContext: EvaluationContext): polars.Expr | undefined
		# {abstract} doEvaluate(leftValue: L, rightValue: R, expression: BinaryExpression): T | undefined
		# polarsDoEvaluate(_left: polars.Expr, _right: polars.Expr, expression: BinaryExpression): polars.Expr | undefined
		}
		DefaultBinaryOperatorEvaluator <|-- AdditionOperatorEvaluator: DefaultBinaryOperatorEvaluator<number, number, number>

		abstract class DefaultUnaryOperatorEvaluator<O, T> {
		DefaultUnaryOperatorEvaluator(operator: string, operandValueTypeGuard: InternalValueRepresentationTypeguard<O>)
		+ <<readonly>> operator: BinaryExpressionOperator
		- <<readonly>> operandValueTypeGuard: InternalValueRepresentationTypeguard<O>
		evaluate(expression: UnaryExpression, evaluationContext: EvaluationContext): T | undefined
		polarsEvaluate(expression: UnaryExpression, evaluationContext: EvaluationContext): polars.Expr | undefined
		# {abstract} doEvaluate(operandValue: O, expression: UnaryExpression): T | undefined
		# polarsDoEvaluate(_operand: polars.Expr, expression: UnaryExpression): polars.Expr | undefined
		}

		interface PolarsOperatorEvaluator<E> {
				<<readonly>> operator: E['operator']
				polarsEvaluate(expression: E, evaluationContext: EvaluationContext): polars.Expr | undefined
			}
		PolarsOperatorEvaluator <|.. DefaultBinaryOperatorEvaluator
		PolarsOperatorEvaluator <|.. DefaultUnaryOperatorEvaluator

		interface OperatorEvaluator<E> {
				<<readonly>> operator: E['operator']
				evaluate(expression: E, evaluationContext: EvaluationContext): InternalValueRepresentation | undefined
			}
		OperatorEvaluator <|-- PolarsOperatorEvaluator

		interface OperatorEvaluatorRegistry {
				unary: Record<UnaryExpressionOperator,PolarsOperatorEvaluator<UnaryExpression>>
				binary: Record<BinaryExpressionOperator, PolarsOperatorEvaluator<BinaryExpression>>
			}

		class DefaultOperatorEvaluatorRegistry implements OperatorEvaluatorRegistry {
				DefaultOperatorEvaluatorRegistry(valueTypeProvider: ValueTypeProvider)
				- <<readonly>> valueTypeProvider: ValueTypeProvider
				unary: Record<UnaryExpressionOperator, UnaryOperatorTypeComputer>
				binary: Record<BinaryExpressionOperator, BinaryOperatorTypeComputer>
			}
		DefaultOperatorEvaluatorRegistry "1" -- "1" AdditionOperatorEvaluator: "'+'"
		DefaultOperatorEvaluatorRegistry "1" -- "1" RoundOperatorEvaluator: "'round'"
		@enduml
	\end{plantuml}
	\caption{Assuming the only operations were \Verb|round| and \Verb|plus|, this is how the Evaluators would be structured}
	\label{fig:uml:evaluators}
\end{figure}
