\chapter{Architecture}
\label{chapter:Architecture}

\section{Requirements}
\label{section:Requirements}

We follow the established practice of differentiating between functional and non functional requirements.
These requirements have been evaluated for completenes, consistency and feasability.

\subsection{Functional Requirements}
\label{subsection:FunctionalRequirements}

% As we've described in \ref{chapter:Literature} tables are a crucial factor of the Jayvee interpreter's performance.
Tables are the central way Jayvee represent's data.
The other types like \Verb|TextFile| or \Verb|Sheet| mostly exists to be parsed into tables.
Hence % TODO: ?
we shall focus on how to efficiently represent tables in memory.
Since Jayvee's \Verb|TableTransformer| work on columns and not rows, the advantages of the columnar format outlined in %TODO: ref
lend themselves well to jayvee.
Jayvee needs manipulate the data, so data needs to be stored in memory not on disk.
This leads to the requirement that \emph{tables are represented with a columnar, in-memory data layout}.

The goal of this thesis is not to create a fully mature implementation of this new format, but rather to prototype an integration and evaluate the results of this migration.
However to accurately evaluate the changes, the core functionality of jayvee (parse data into table, apply function to columns of that table, export table) needs to be preserved.
\emph{Core functionality is maintained}.
This includes that tables can still be created in the same ways (\Verb|TableIntepreter|) and exported with the same blocks (\Verb|SQLiteLoader|) (\Verb|PostresLoader|).
\emph{Arithmetic operations work in transforms}.

Should it be necessary to write code in a language other than typescript, this code must be placed in an external library usable from typesript.
This ensures usability and increases maintainability by for other developers.

To make evaluation easier the new implementation must be choosable with a commandline flag \emph{at runtime}.

\subsection{Non Functional Requirements}
\label{subsection:NonFunctionalRequirements}

- as little as possible interferance with the typescript stuff

The main goal of this thesis is to \emph{optimize} Jayvee's in-memory representation.
Therefore, the \emph{time needed to execute Jayvee pipelines should decrease} or \emph{the capabilities of the interpreter must be extended}.

The source code is readable for non-rust developers.
Informative log messages are generated.
The source code adheres to the project's code style.

\section{Interpreter Overview}
\label{section:prev}

In this section, we will give an overview of how the interpreter executes a jayvee pipeline.

Pipeline definitions in jayvee consist of a series of block definitions.
At runtime, the jayvee interpreter associates each block-definition with a class implementing the \Verb|BlockExecutor<I extends IOType, O extends IOType>| interface.
\Verb|IOType| is an enum specifing all of the allowed types inputs and ouptuts can have (see \ref{lst:iotype}), which is made use of by the \Verb|IOTypeImplementation<T extends IOType>| interface, whose implementors are the actual inputs and ouptuts.
\begin{listing}
	\begin{minted}{typescript}
enum IOType {
	NONE = 'None',
	FILE = 'File',
	TEXT_FILE = 'TextFile',
	FILE_SYSTEM = 'FileSystem',
	SHEET = 'Sheet',
	TABLE = 'Table',
	WORKBOOK = 'Workbook',
}
\end{minted}
	\caption{The \Verb{IOType} enum}
	\label{lst:iotype}
\end{listing}
One of these is the \Verb|Table| class which implements \Verb|IOTypeImplementation<IOType.TABLE>|, and can thus serve as both input and output to blocks using tables.
For an overview of how \Verb{Table} fits into the interpreter, see \ref{fig:prev_sit}.
% This interface also provides the method \mint{typescript}|execute(input: IOTypeImplementation<I>, context: ExecutionContext): Promise<R.Result<IOTypeImplementation<O>>>|.
% These inputs/outputs must fall into one of seven categories (see \ref{lst:iotype}).
% Jayvee uses this \Verb|IOType| via \Verb|IOTypeImplementation<T>| where \Verb|T| is a variant of the \Verb|IOType| enum.

\begin{figure}
	\begin{plantuml}
		@startuml
		hide members

		interface BlockExecutor
		interface BlockExecutorClass

		interface IOTypeImplementation
		BlockExecutor  -  IOTypeImplementation: input
		BlockExecutor - IOTypeImplementation: output
		class Table implements IOTypeImplementation

		abstract class AbstractBlockExecutor implements BlockExecutor
		class TableTransformerExecutor extends AbstractBlockExecutor implements BlockExecutorClass

		class TransformExecutor
		TableTransformerExecutor -- TransformExecutor: creates and executes >

		interface OperatorEvaluator
		abstract class DefaultBinaryOperatorEvaluator implements OperatorEvaluator
		abstract class DefaultUnaryOperatorEvaluator implements OperatorEvaluator
		class AdditionOperatorEvaluator extends DefaultBinaryOperatorEvaluator
		class RoundOperatorEvaluator extends DefaultUnaryOperatorEvaluator

		interface OperatorEvaluatorRegistry
		class DefaultOperatorEvaluatorRegistry implements OperatorEvaluatorRegistry
		TransformExecutor -- OperatorEvaluatorRegistry: looks up ""operator"" >
		OperatorEvaluatorRegistry - OperatorEvaluator: operator to implementation >
		@enduml
	\end{plantuml}
	\caption{The general structure of the jayvee interpreter. Subclasses and implementations have been omitted for readabiltiy}
	\label{fig:uml:overview}
\end{figure}


\begin{figure}
	\begin{plantuml}
		@startuml
		hide empty members

		interface PipelineDefinition
		interface BlockDefinition

		interface BlockExecutor<I extends IOType, O extends IOType> {
				+execute(input: IOTypeImplementation<I\>, context: ExecutionContext): Result<IOTypeImplementation<O>>
			}

		interface BlockExecutorClass {}

		PipelineDefinition "1" *-- "many" BlockDefinition
		BlockDefinition "1" --> "1" BlockExecutor: interpreter finds fitting implementation %FIXME: fitting

		interface IOTypeImplementation<T extends IOType>
		IOTypeImplementation - BlockExecutor: input
		IOTypeImplementation - BlockExecutor: output

		class Table
		IOTypeImplementation <|.. Table : IOTypeImplementation<IOType.TABLE>

		abstract class AbstractBlockExecutor<I extends IOType, O extends IOType> implements BlockExecutor {
		+ {abstract} doExecute(input: IOTypeImplementation<I\>, context: ExecutionContext): Result<IOTypeImplementation<O\>>
		}

		class TableTransformerExecutor {
				+doExecute(input: Table, context: ExecutionContext): Result<Table>
			}
		AbstractBlockExecutor <|-- TableTransformerExecutor: AbstractBlockExecutor<IOType.TABLE, IOType.TABLE>
		BlockExecutorClass <|-- TableTransformerExecutor
		@enduml
	\end{plantuml}
	\caption{How \Verb|Table| fits into the interpreter} %FIXME
	\label{fig:prev_sit}
\end{figure}

\section{General Idea}
\label{section:General Idea}

Adapting Jayvee Tables to implement the apache arrow format fulfills the functional requirements of a standardized, columnar, in-memory representation.
Additionaly Arrow is optimized for modern CPUs and GPUs, and organized for efficent analytical workloads, which will get us closer to the non functional requrement of decreased runtime. % TODO: citation

\begin{figure}
	\begin{plantuml}
		@startuml
		start
		:start interpreter;
		:parse model;
		if (parseOnly) then (yes)
		else (no)
		while (more pipeline)
		partition run pipelines {
				:sort blocks into execution order;
				while (more blocks)
				partition run block {
						partition get block exectutor {
								if (block has multiple executors) then (yes)
								if (usePolars) then (true)
								:pick polars executor;
								else (false)
								:pick typescript executor;
								endif
								else (no)
								:pick general executor;
								endif
							}
						:call exectutor;
						note
						<code>
						BlockExecutor<I extends IOType,O extends IOType>.execute(
						input: IOTypeImplementation<I>,
						context: ExectutionContext
						): Result<IOTypeImplementation<O>>
						</code>
						end note
						:save output as input for the next block;
					}
				endwhile
			}
		endwhile
		endif
		stop
		@enduml
	\end{plantuml}
	\caption{An activity diagram overview of the interpreter}
	\label{fig:interpreter_activity}
\end{figure}


\subsection{Possible implementations}
\label{subsection:arrow implementations}

In this section, we will discuss possible implementations of the arrow specification.

\subsubsection{Implementation from scratch}
\label{subsubsection:direct_implementation}
The most direct option is to implement the Arrow specification directily.
This would have the advantage of having full control over the implementation.
It is not guaranteed that an enough of the specification can be implemented within the timeframe of the thesis.
This implementation would probably perform worse than a mature implementation.
Correctness is hard to guarantee.

An implementation from scratch is \emph{too big in scope} for a bachelor's thesis.

\subsubsection{Apache arrow in JS}
\label{subsubsection:arrow_in_js}
There is an implementation of arrow in typescript.
This has the advantage of being the same lanugage as the jayvee interpreter.
typescript on nodejs has a reputation of being slow compared to other languages. % TODO: citation
this implementation is comparable to other languages in terms of supported datatypes, but is lacks behind in support for other apache frameworks \autocite{arrow:status}, which takes away one of arrow's strengths.

Considering this, an implementation inside a compiled language, that offers a typescript api seems preferable.

\subsubsection{Polars}
\label{subsection:polars}
As described in % TODO: reference.
Polars is a high level api built on top of apache arrows, but it also offers useful abstractions like dataframes.
It also promises huge %FIXME: wording
speed gains compared to it's competitors %TODO: citation

%TODO: bild Ã¼ber abstraktion polars zu js.

The Dataframe abstractions allows us to get the in-memory layout we want, by simply creating an adapter %FIXME: design pattern is strategy not adapter
between the interpeter classes utilising tables and the polars dataframe.


\section{The strategy pattern}
The requirement to pick the implementation at runtime makes the strategy pattern really appealing. %FIXME: wording
%TODO: Describe strategy pattern more

\section{Type conversion}
- jayvee valuetypes and polars datatypes are not compatible ootb
- need for conversion between the two
- jayvee also has InternalValueRepresentation (stuff that expressions can evaluate to)
- wrong apporach:
- add the polars datatypes to internalvaluerepresentation
- they do not contain actual data, they are values representing types
- tried to do strategy on valuetypeproviders, didn't work
- right approach:
- jayvee is able to convert between valuetypes and polars datatypes when required

\section{Table IOType} %TODO: find an actual title
\label{section:new_table}

We move all of the functionality from \Verb{Table} to \Verb{TsTable} and create a new \emph{abstract} class \Verb|Table|.

\subsection{abstract table}
This differs from the usual stratergy pattern in that, normally, an interface is used to represent the shared functionality between the algorithms.
- usually the strategy pattern is done with an interface.
- using an abstract class allows us to implement shared behaviour for both.


\subsubsection{changes compared to old table}
- The \Verb|addColumn| method was replaced with the \Verb|withColumn| metod
- leads to less mutations, so it's better for parallel execution %TODO: citation
- \Verb|isPolars| and \Verb|isTypescript| typeguards were added
- utilised the \Verb|get| keyword for \Verb|getNumberOfColumns|

\begin{figure}
	\begin{plantuml}
		@startuml
		abstract class Table {
				{abstract} <<getter>> nRows(): number
					{abstract} <<getter>>  nColumns(): number
					{abstract} <<getter>> columns(): ReadonlyArray<TableColumn>
					{abstract} withColumn(column: TableColumn): Table
					{abstract} hasColumn(name: string): boolean
					{abstract} getColumn(name: string): TableColumn | undefined
					{abstract} getRow(id: number): TableRow
					{abstract} clone(): Table
					{abstract} acceptVisitor<R>(visitor: IoTypeVisitor<R>): R
					{abstract} isPolars(): this is PolarsTable
					{abstract} isTypescript(): this is TsTable
					{static} generateDropTableStatement(tableName: string): string
					{abstract} generateInsertValuesStatement(tableName: string): string
					{abstract} generateCreateTableStatement(tableName: string): string
			}
		@enduml
	\end{plantuml}
	\caption{The class diagram of the \Verb{Table} class}
	\label{fig:uml:table}
\end{figure}


\subsection{PolarsTable}
The Polars class \Verb|DataFrame| is made useful to the jayvee interpreter by wrapping it in a new class \Verb|PolarsTable|.
- this is similar to the adapter pattern %TODO: citation
\Verb|PolarsTable| extends \Verb|Table| and thereby also implements \Verb|IOTypeImplementation<IOType.Table>|.
- this makes PolarsTable usable as input / output for blocks
\begin{figure}
	\begin{plantuml}
		@startuml
		class PolarsTable {
				-df: polars.DataFrame
				-valueTypeProvider: ValueTypeProvider
				<<getter>> nRows(): number
				<<getter>> nColumns(): number
				<<getter>> columns(): readonly PolarsTableColumn[]
				getTypes(): ValueType[]
				generateInsertValuesStatement(tableName: string): string
				generateCreateTableStatement(tableName: string): string
				withColumn(column: PolarsTableColumn): PolarsTable
				withColumnFromInternal(expr: PolarsInternal): PolarsTable
				hasColumn(name: string): boolean
				getColumn(name: string): PolarsTableColumn | undefined
				getRow(id: number): TableRow
				clone(): PolarsTable
				acceptVisitor<R>(visitor: IoTypeVisitor<R>): R
				isPolars(): this is PolarsTable
				isTypescript(): this is TsTable
				toString(): string
				writeIpc(options?: WriteIPCOptions): Buffer
				writeIpcTo(destination: string | Writable, options?: WriteIPCOptions): void
			}
		@enduml
	\end{plantuml}
	\caption{The class diagram of the \Verb{PolarsTable} class}
	\label{fig:polarstable_uml}
\end{figure}

\subsubsection{ValueTypeProvider}
This tells the jayvee interpreter jayvee specific type a value has.
This information is saved on a per column basis in the typescript backend.
The polars backend cannot do this, because the polars has its own valuetype system.
- save valueTypeProvider to reinfer the valuetype when creating columns

\subsection{TableColumn}
\subsubsection{abstract tableColumn}
- previos interface did contan a array of all the values.
\begin{figure}
	\begin{plantuml}
		@startuml
		interface TableColumn<T extends InternalValueRepresentation>{
				+values: T[]
				+valueType: ValueType
			}
		@enduml
	\end{plantuml}
	\caption{The old \Verb|TableColumn|}
	\label{fig:uml:old_tablecolumn}
\end{figure}
- not applicable to the general tablecolumn anymore
- same approach as with abstract table
- so this \ref{fig:uml:tablecolumn}:
\begin{figure}
	\begin{plantuml}
		@startuml
		abstract class TableColumn{
				{abstract} <<getter>> valueType(): ValueType
					{abstract} <<getter>> length(): number
					{abstract} <<getter>> name(): string
					{abstract} <<setter>> name(newName: string)
				{abstract} nth(n: number): InternalValueRepresentation | undefined | null
					{abstract} clone(): TableColumn
					{abstract} isPolars(): this is PolarsTableColumn
					{abstract} isTypescript(): this is TsTableColumn
			}
		@enduml
	\end{plantuml}
	\caption{The \Verb|TableColumn| class diagram}
	\label{fig:uml:tablecolumn}
\end{figure}

\subsubsection{PolarsTableColumn}
\begin{figure}
	\begin{plantuml}
		@startuml
		class PolarsTableColumn {
				-_valueType: ValueType;
				-_series: polars.Series
				PolarsTableColumn(_series: Series, valueType: ValueType | ValueTypeProvider)
				<<getter>> valueType(): ValueType
				<<getter>> series(): Readonly<pl.Series>
				<<getter>> length(): number
				<<getter>> name(): string
				<<setter>> name(newName: string)
				nth(n: number): InternalValueRepresentation | undefined | null
				clone(): PolarsTableColumn
				isPolars(): this is PolarsTableColumn
				isTypescript(): this is TsTableColumn
			}
		@enduml
	\end{plantuml}
	\caption{The \Verb|PolarsTableColumn| class diagram}
	\label{fig:uml:polastablecolumn}
\end{figure}

\subsubsection{TsTableColumn}
\begin{figure}
	\begin{plantuml}
		@startuml
		class TsTableColumn<T extends InternalValueRepresentation> {
				- name: string
				-_valueType: ValueType<T>;
				-_values: T[]
				TsTableColumn(_name, _valueType, _values)
				<<getter>> valueType(): ValueType
				<<getter>> length(): number
				<<getter>> name(): string
				<<setter>> name(newName: string)
				nth(n: number): T | undefined
				clone(): TsTableColumn
				isPolars(): this is PolarsTableColumn
				isTypescript(): this is TsTableColumn
				push(element: T)
				drop(index: number)
			}
		@enduml
	\end{plantuml}
	\caption{The \Verb|PolarsTableColumn| class diagram}
	\label{fig:uml:tstablecolumn}
\end{figure}

\subsection{How it fits together}
\begin{figure}
	\begin{plantuml}
		@startuml
		hide empty members
		interface IOTypeImplementation<T extends IOType = IOType> {
				+ioType: T
				+acceptVisitor<R>(vistor: IoTypeVisitor<R>): R
			}
		abstract class Table {
				+ioType: IOType.TABLE
			}
		IOTypeImplementation <|.. Table : IOtypeImplementation<IOType.TABLE>
		abstract class TableColumn {
			}
		class PolarsTable extends Table {
				PolarsTable(df, valueTypeProvider)
				-df: polars.DataFrame
				-valueTypeProvider: ValueTypeProvider
			}
		class TsTable extends Table {
				TsTable(numberOfRows, _columns)
				-numberOfRows: number
				-_columns: Map<string, TsTableColumn>
			}
		class PolarsTableColumn extends TableColumn {
				-series: polars.Series
			}
		class TsTableColumn<T extends InternalValueRepresentation> extends TableColumn {
			}
		TsTable "1" *-- "many" TsTableColumn
		PolarsTable "1" *-- "1" polars.DataFrame: df
		PolarsTableColumn "1" *-- "1" polars.Series: series
		@enduml
	\end{plantuml}
	\caption{How jayvee represents tables} % FIXME
	\label{fig:current_sit}
\end{figure}

\section{new executors}
- block executors are grouped in extensions.
- the jayvee interpreter calls createBlockExecutor() when looking for a block
- the extension returns a fitting result
\begin{figure}
	\begin{plantuml}
		@startuml
		abstract class JayveeExecExtension {
				{abstract} getBlockExecutors(): BlockExecutorClass[]
				getExecutorForBlockType(blockTypeName: string, usePolars: boolean, useRusqlite: boolean, logger: Logger): BlockExecutorClass | undefined
				createBlockExecutor(block: BlockDefinition, usePolars: boolean, useRusqlite: boolean, logger: Logger): BlockExecutor
			}
		class StdExecExtension extends JayveeExecExtension {
				getBlockExecutors(): BlockExecutorClass[]
			}
		class TabularExecExtension extends JayveeExecExtension {
				getBlockExecutors(): BlockExecutorClass[]
			}
		class RdbmsExecExtension extends JayveeExecExtension {
				getBlockExecutors(): BlockExecutorClass[]
			}
		@enduml
	\end{plantuml}
	\caption{} %TODO:
	\label{fig:uml:jayveeexecextension}
\end{figure}


\begin{figure}
	\begin{plantuml}
		@startuml
		abstract class JayveeExecExtension {
				{abstract} getBlockExecutors(): BlockExecutorClass[]
				getExecutorForBlockType(blockTypeName: string, usePolars: boolean, useRusqlite: boolean, logger: Logger): BlockExecutorClass | undefined
				createBlockExecutor(block: BlockDefinition, usePolars: boolean, useRusqlite: boolean, logger: Logger): BlockExecutor
			}

		class StdExecExtension extends JayveeExecExtension {
				getBlockExecutors(): BlockExecutorClass[]
			}
		class TabularExecExtension extends JayveeExecExtension {
				getBlockExecutors(): BlockExecutorClass[]
			}
		class RdbmsExecExtension extends JayveeExecExtension {
				getBlockExecutors(): BlockExecutorClass[]
			}
		annotation implementsStatic<T>
		interface BlockExecutorClass<T extends BlockExecutor> {
				<<readonly>> type: string
			}
		interface BlockExecutor<I extends IOType, O extends IOType> {
				<<readonly>> inputType: I
				<<readonly>> outputType: O
				execute(input: IOTypeImplementation<I\>, context): Result<IOTypeImplementation<O>>
			}
		abstract class AbstractBlockExecutor<I extends IOType, O extends IOType> implements BlockExecutor {
				AbstractBlockExecutor(inputType, outputType)
				-logBlockResult(result: IOTypeImplementation, context)
				{abstract} doExecute(input: IOTypeImplementation<I\>, context): Result<IOTypeImplementation<O>>
			}
		class TableTansfromerExecutor {}
		AbstractBlockExecutor <|-- TableTansfromerExecutor: AbstractBlockExecutor<IOType.TABLE, IOType.TABLE>
		implementsStatic - TableTansfromerExecutor: @implementsStatic<BlockExecutorClass>
		(TableTansfromerExecutor, implementsStatic) <|.. BlockExecutorClass: BlockExecutorClass<TableTansfromerExecutor>
		BlockExecutorClass .. JayveeExecExtension
		@enduml
	\end{plantuml}
	\caption{}
	\label{fig:}
\end{figure}

- block executors extend this abstract class:
\begin{figure}
	\begin{plantuml}
		@startuml
		interface BlockExecutor<I extends IOType, O extends IOType> {
				<<readonly>> inputType: I
				<<readonly>> outputType: O
				execute(input: IOTypeImplementation<I\>, context): Result<IOTypeImplementation<O>>
			}
		abstract class AbstractBlockExecutor<I extends IOType, O extends IOType> implements BlockExecutor {
				AbstractBlockExecutor(inputType, outputType)
				-logBlockResult(result: IOTypeImplementation, context)
				{abstract} doExecute(input: IOTypeImplementation<I\>, context): Result<IOTypeImplementation<O>>
			}
		@enduml
	\end{plantuml}
	\caption{} %TODO:
	\label{fig:uml:abstractblockexecutor}
\end{figure}

\subsection{TableInterpreter}
- same approach as always (strategy).
- move previous implementation into \Verb|TsTableInterpreter|
- create abstract class \Verb|TableInterpreter|
- create new class \Verb|PolarsTableInterpreter|
- \Verb|toPolarsDataTypeWithLogs| is its own mehtod to enable code sharing with other table blocks.
- can't be in language-server because circular dependency
- uses the already present \Verb|ColumnDefintionEntry|

\begin{figure}
	\begin{plantuml}
		@startuml
		abstract class TableInterpeter {
		doExecute(inputSheet: Sheet, context: R.ExecutionContext): Promise<R.Result<R.Table>>
		# {abstract} constructAndValidateTable(sheet: Sheet, header: boolean, columnEntries: ColumnDefinitionEntry[], context: ExecutionContext): Table
		#deriveColumnDefinitionEntriesWithoutHeader(columnDefinitions: ValuetypeAssignment[], context: ExecutionContext): ColumnDefinitionEntry[]
		#deriveColumnDefinitionEntriesFromHeader(columnDefinitions: ValuetypeAssignment[], headerRow: string[], context: ExecutionContext): ColumnDefinitionEntry[]
		#parseAndValidateValue(value: string, valueType: ValueType, context: ExecutionContext): InternalValueRepresentation | undefined
		}
		@enduml
	\end{plantuml}
	\caption{}
	\label{fig:uml:tableinterpreter}
\end{figure}

\subsubsection{PolarsTableInterpreter}
\begin{figure}
	\begin{plantuml}
		@startuml
		class PolarsTableInterpreterExecutor {
		+ {static} <<readonly>> type: 'PolarsTableInterpreter' = 'PolarsTableInterpreter';
		# constructAndValidateTable(sheet: Sheet, header: boolean, columnEntries: ColumnDefinitionEntry[], context: ExecutionContext): PolarsTable
		- constructSeries(rows: readonly (readonly string[])[], columnEntry: ColumnDefinitionEntry, context: ExecutionContext): pl.Series
		}
		@enduml
	\end{plantuml}
	\caption{}\label{fig:uml:polarstableinterpreter}
\end{figure}


\subsection{FileToTableIntepreter}
- combine TextFileInterpreter, CSVInterpreter, TableIntepreter.
- can recieve input from FileSelelector %TODO: check name
LocalFileExtrator, HTTPExtractor
\begin{figure}
	\begin{plantuml}
		@startuml
		hide empty members
		class FileToTableInterpreterExecutor {
		+ {static} <<readonly>> type : 'FileToTableInterpreter';
		FileToTableInterpreterExecutor()
		doExecute(file: BinaryFile, context: ExecutionContext): Result<Table>
		+ {static} colsAndSchema(context: ExecutionContext): { columnNames: string[]; schema: Record<string, PlDType>;}
		+ {static} csvOptions(context: ExecutionContext): Partial<ReadCsvOptions>
		+ {static} constructAndValidateTable(content: Buffer, options: Partial<ReadCsvOptions>, context: ExecutionContext): PolarsTable
		+ {static} deriveColumnDefinitionEntriesFromHeader(columnDefinitions: ValuetypeAssignment[], headerRow: string[], context: ExecutionContext): ColumnDefinitionEntry[]
		}
		abstract class AbstractBlockExecutor<I extends IOType, O extends IOType>
		AbstractBlockExecutor <|-- FileToTableInterpreterExecutor: AbstractBlockExecutor<IOType.FILE, IOType.Table>
		@enduml
	\end{plantuml}
	\caption{}\label{fig:uml:filetotableinterpreter}
\end{figure}

\subsection{FileToTableIntepreter}
- combine LocalFileExtractor TextFileInterpreter, CSVInterpreter, TableIntepreter.
\begin{figure}
	\begin{plantuml}
		@startuml
		hide empty members
		class LocalFileToTableInterpreterExecutor {
		+ {static} <<readonly>> type : 'LocalFileToTableInterpreter';
		FileToTableInterpreterExecutor()
		doExecute(file: BinaryFile, context: ExecutionContext): Result<Table>
		+ constructAndValidateTable(content: None, options: Partial<ReadCsvOptions>, context: ExecutionContext): PolarsTable
		}
		abstract class AbstractBlockExecutor<I extends IOType, O extends IOType>
		AbstractBlockExecutor <|-- FileToTableInterpreterExecutor: AbstractBlockExecutor<IOType.NONE, IOType.Table>
		@enduml
	\end{plantuml}
	\caption{}\label{fig:uml:localfiletotableinterpreter}
\end{figure}

\subsection{TableTransformer}
\subsubsection
- again strategy.
